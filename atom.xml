<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Consen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://consen.github.io/"/>
  <updated>2018-01-05T09:48:15.424Z</updated>
  <id>https://consen.github.io/</id>
  
  <author>
    <name>Consen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SystemTap</title>
    <link href="https://consen.github.io/2018/01/04/systemtap/"/>
    <id>https://consen.github.io/2018/01/04/systemtap/</id>
    <published>2018-01-04T21:15:49.000Z</published>
    <updated>2018-01-05T09:48:15.424Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">SystemTap</a>是一款Linux跟踪探测（trace/probe）工具，可收集Linux运行信息，用于性能诊断和问题排查等。SystemTap不需要每次都对内核修改、编译、安装、重启等繁杂冗余的操作，通过其自定义的脚本语言，即可编写功能丰富强大的探测模块，动态载入内核，对系统进行监控，获取指定信息。</p><p>SystemTap可以监控系统调用、内核函数及其他发生在内核的事件（event），当事件触发时，运行指定处理例程（handler）。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SystemTap基于<a href="https://www.kernel.org/doc/Documentation/kprobes.txt" target="_blank" rel="external">Kprobes</a>实现，Kprobes允许在内核代码任意地址设置断点，当断点触发时，运行指定的处理例程。Kprobes有两种探测类型：kprobes和kretprobes，kprobes可以探测内核任意指令，kretprobes探测函数返回。当注册一个kprobe时，会拷贝一份探测指令，然后将指令的第一个字节替换成断点指令（如int3），断点触发时运行指定处理函数，然后运行原始指令。当注册一个kretprobe，会在探测函数入口点注册一个常规的kprobe，当函数调用时，会获取返回地址，然后将返回地址替换成一个跳转地址（trampoline address），当函数返回时，运行跳转地址，此时处理函数执行，然后再运行原始返回地址。</p><p>SystemTap的运行分以下5个步骤：</p><ol><li>parse，解析脚本，转换成解析树（parse tree），这个阶段还会进行预处理，语法语义检查。</li><li>elaboration，解析脚本中符号和引用，依赖tapsets（预编写的脚本库）和调试信息。</li><li>translate, 将第2步输出转换成C代码。</li><li>build，将C代码编译成内核模块。</li><li>run，加载内核模块并运行。</li></ol><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/systemtap/systemtap-arch.png" alt="systemtap-arch"></p><p>stap命令完成前4步，第5步由staprun和stapio完成。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/systemtap/systemtap-flow.png" alt="systemtap-flow"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>各Linux发行版如Ubuntu、CentOS等，都提供了SystemTap安装包，直接通过包管理命令安装即可，这里采用<a href="https://sourceware.org/git/?p=systemtap.git;a=blob_plain;f=README;hb=HEAD" target="_blank" rel="external">源码编译</a>方式安装。</p><p>从<a href="https://sourceware.org/systemtap/wiki/SystemTapReleases" target="_blank" rel="external">SystemTap Releases</a>下载最新版源码，编译安装，依赖的第三方工具及开发包直接通过包管理命令安装即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd systemtap-3.2</span><br><span class="line">$ ./configure</span><br><span class="line">$ make -j 20</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>SystemTap借助调试信息来确定内核探测点地址，需要调试版内核，这里重新编译Linux-4.14内核。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd linux-4.14-debuginfo</span><br><span class="line">$ vim Makefile</span><br></pre></td></tr></table></figure><p>可以修改<code>Makefile</code>中的<code>EXTRAVERSION</code>为<code>EXTRAVERSION = -debuginfo</code>，这样安装后内核版本为<code>4.14.0-debuginfo</code>，以便和非调试版内核做区分。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp ../linux-4.14/.config ./</span><br><span class="line">$ make menuconfig</span><br></pre></td></tr></table></figure><p>配置内核参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">General setup  ---&gt;</span><br><span class="line">    -*- Kernel-&gt;user space relay support (formerly relayfs)</span><br><span class="line">    [*] Kprobes</span><br><span class="line">Kernel hacking  ---&gt; </span><br><span class="line">    [*] Kernel debugging</span><br><span class="line">    Compile-time checks and compiler options  ---&gt;</span><br><span class="line">        [*] Compile the kernel with debug info</span><br><span class="line">        -*- Debug Filesystem</span><br></pre></td></tr></table></figure><p>配置完后，检查<code>.config</code>配置文件中以下参数都已配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_DEBUG_INFO</span><br><span class="line">CONFIG_KPROBES</span><br><span class="line">CONFIG_RELAY</span><br><span class="line">CONFIG_DEBUG_FS</span><br></pre></td></tr></table></figure><p>编译安装内核：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make -j 20</span><br><span class="line">$ sudo make modules_install</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>重启系统，检查SystemTap是否安装成功：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">4.14.0-debuginfo</span><br><span class="line"></span><br><span class="line">$ sudo stap -ve &apos;probe begin &#123; log(&quot;hello world&quot;) exit() &#125;&apos;</span><br><span class="line">Pass 1: parsed user script and 469 library scripts using 182836virt/49676res/5624shr/44624data kb, in 330usr/30sys/350real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe, 2 functions, 0 embeds, 0 globals using 183628virt/50828res/6016shr/45416data kb, in 10usr/0sys/8real ms.</span><br><span class="line">Pass 3: translated to C into &quot;/tmp/stapplkAR0/stap_b9273d87672a231f62a6c5ceae813d9a_1099_src.c&quot; using 183760virt/50828res/6016shr/45548data kb, in 0usr/0sys/0real ms.</span><br><span class="line">Pass 4: compiled C into &quot;stap_b9273d87672a231f62a6c5ceae813d9a_1099.ko&quot; in 12300usr/2260sys/14357real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">hello world</span><br><span class="line">Pass 5: run completed in 0usr/20sys/356real ms.</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>SystemTap安装好后，自带的示例脚本位于<code>/usr/local/share/systemtap/examples/</code>，编写脚本可以作为参考。tapsets位于<code>/usr/local/share/systemtap/tapset/</code>。</p><p>SystemTap脚本语言借鉴了dtrace和awk，SystemTap脚本以<code>.stp</code>作为文件扩展名，包含的探测点采用如下格式编写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">probe event &#123;statement&#125;</span><br></pre></td></tr></table></figure><p>这里以探测sshd进程的系统调用统计为例，了解SystemTap脚本的使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global syscalllist</span><br><span class="line"></span><br><span class="line">probe begin &#123;</span><br><span class="line">  printf(&quot;SSHD Monitoring Started (10 seconds)...\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.*</span><br><span class="line">&#123;</span><br><span class="line">  if (execname() == &quot;sshd&quot;) &#123;</span><br><span class="line">    syscalllist[name]++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.ms(10000) &#123;</span><br><span class="line">  foreach ( name in syscalllist ) &#123;</span><br><span class="line">    printf(&quot;%s = %d\n&quot;, name, syscalllist[name] )</span><br><span class="line">  &#125;</span><br><span class="line">  exit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">  printf(&quot;SSHD Monitoring Ended\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里脚本运行10s，输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo stap sshd_profile.stp</span><br><span class="line">Syslog Monitoring Started (10 seconds)...           </span><br><span class="line">rt_sigprocmask = 144                                </span><br><span class="line">read = 36                                           </span><br><span class="line">select = 72                                         </span><br><span class="line">write = 36                                          </span><br><span class="line">ioctl = 12</span><br><span class="line">SSHD Monitoring Ended</span><br></pre></td></tr></table></figure><p>调用exit()退出，也可通过<code>Ctrl-c</code>退出。</p><p>SystemTap会缓存脚本转换后的C语言和内核模块，如果脚本没有更改，再次运行时不必重新构建，直接使用之前的。</p><p>也可显示保存构建的内核模块，供后续直接使用，<code>-m</code>指定内核模块名，<code>-p4</code>表示处理到第4阶段停止：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo stap -v -m sshd_profile.ko -p4 sshd_profile.stp</span><br></pre></td></tr></table></figure><p><code>staprun</code>运行编译好的模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo staprun sshd_profile.ko</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://sourceware.org/systemtap/tutorial.pdf" target="_blank" rel="external">Systemtap tutorial</a></li><li><a href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide.pdf" target="_blank" rel="external">SystemTap Beginners Guide</a></li><li><a href="https://sourceware.org/systemtap/archpaper.pdf" target="_blank" rel="external">Architecture of systemtap: a Linux trace/probe tool</a></li><li><a href="https://sourceware.org/systemtap/langref.pdf" target="_blank" rel="external">SystemTap Language Reference</a></li><li><a href="http://www.redbooks.ibm.com/redpapers/pdfs/redp4469.pdf" target="_blank" rel="external">SystemTap: Instrumenting the Linux Kernel for Analyzing Performance and Functional Problems</a></li><li><a href="https://www.ibm.com/developerworks/library/l-systemtap/index.html" target="_blank" rel="external">Linux introspection and SystemTap</a></li><li><a href="https://www.ibm.com/developerworks/library/l-kprobes/index.html" target="_blank" rel="external">Kernel debugging with Kprobes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://sourceware.org/systemtap/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SystemTap&lt;/a&gt;是一款Linux跟踪探测（trace/probe）工具，可收集Linux运行信息，用于性能诊断和问题排查等。SystemTap不需要每次都对内核修改、编译、安装、重启等繁杂冗余的操作，通过其自定义的脚本语言，即可编写功能丰富强大的探测模块，动态载入内核，对系统进行监控，获取指定信息。&lt;/p&gt;
&lt;p&gt;SystemTap可以监控系统调用、内核函数及其他发生在内核的事件（event），当事件触发时，运行指定处理例程（handler）。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://consen.github.io/categories/Linux/"/>
    
    
      <category term="SystemTap" scheme="https://consen.github.io/tags/SystemTap/"/>
    
  </entry>
  
  <entry>
    <title>KVM运行macOS</title>
    <link href="https://consen.github.io/2017/12/23/kvm-run-macos/"/>
    <id>https://consen.github.io/2017/12/23/kvm-run-macos/</id>
    <published>2017-12-23T20:08:22.000Z</published>
    <updated>2018-01-04T13:55:01.006Z</updated>
    
    <content type="html"><![CDATA[<p>最近尝试基于Xen运行macOS操作系统，之前已经有人做过类似的研究：</p><ul><li><a href="http://wiki.osx86project.org/wiki/index.php/Snow_Leopard_Server_on_Xen" target="_blank" rel="external">Snow Leopard Server on Xen</a></li><li><a href="https://www.bisente.com/2011/03/15/macos-xen-snow-leopard-as-guest-on-a-xen-domu/" target="_blank" rel="external">MACOS XEN: SNOW LEOPARD AS GUEST ON A XEN DOMU</a></li><li><a href="https://groups.google.com/forum/#!msg/qubes-users/RiVntUzgJmY/rXMtXD3WKQAJ" target="_blank" rel="external">Qubes 3 MacOSX</a></li></ul><p>虽然可正常运行，但缺少后续研究，也没有官方支持，所以目前为止Xen只能勉强运行老版本OSX操作系统。运行OSX系统，需要对Xen hypervisor进行修改，如支持MSR 0x35，OSX系统启动时需要据此确定CPU核心数和线程数，但是这个特性连Intel官方开发文档都没有明确说明，所以Xen官方拒绝将此修改合并到Xen主分支代码。</p><ul><li><a href="https://lists.xen.org/archives/html/xen-devel/2014-09/msg02524.html" target="_blank" rel="external">Xen-devel PATCH x86/hvm: add support for MSR 0x35</a></li><li><a href="https://lists.xen.org/archives/html/xen-devel/2014-09/msg02525.html" target="_blank" rel="external">Xen-devel PATCH x86/traps: hypervisor leaf 0x40000010 timing info</a></li></ul><p>自己在本地修改Xen源码，虽然可安装、启动OSX-10.10系统，但还是遇到了其他问题，如外设模拟、系统驱动等，所以系统还是没法正常使用，只好作罢，转而投向更加活跃、有社区支持的<a href="https://github.com/kholia/OSX-KVM" target="_blank" rel="external">OSX-KVM</a>项目，基于KVM运行macOS系统。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>运行KVM需要CPU支持虚拟化扩展，即Intel VT-x或AMD SVM，如果功能没开启，需要在BISO开启。运行OSX需要KVM和QEMU支持，对KVM和QEMU的修改都已合并到主分支代码，如果系统自带的KVM或QEMU版本太老，OSX是无法正常运行的，至少需要Linux kernel &gt;= 4.7，QEMU &gt;= 2.6。</p><p>在<a href="https://www.kernel.org/" target="_blank" rel="external">The Linux Kernel Archives</a>下载最新稳定版Linux内核编译安装，注意KVM相关虚拟化参数配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">4.14.0</span><br></pre></td></tr></table></figure><p>加载KVM内核模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo modprobe kvm_intel</span><br><span class="line">$ lsmod | grep kvm</span><br><span class="line">kvm_intel             192512  0</span><br><span class="line">kvm                   512000  1 kvm_intel</span><br><span class="line">irqbypass              16384  1 kvm</span><br></pre></td></tr></table></figure><p>在<a href="https://www.qemu.org/download/#source" target="_blank" rel="external">Download QEMU</a>下载最新稳定版QEMU编译安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ /usr/local/bin/qemu-system-x86_64 --version                                          </span><br><span class="line">QEMU emulator version 2.11.0                        </span><br><span class="line">Copyright (c) 2003-2017 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><h2 id="安装macOS"><a href="#安装macOS" class="headerlink" title="安装macOS"></a>安装macOS</h2><p>接着按照<a href="https://github.com/kholia/OSX-KVM" target="_blank" rel="external">OSX-KVM</a>系统安装文档，安装macOS系统。我直接使用的<code>qemu-system-x86_64</code>，没有借助<code>libvirt</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat boot-macOS.sh</span><br><span class="line">qemu-system-x86_64 -enable-kvm -m 2048 -cpu Penryn,kvm=off,vendor=GenuineIntel \</span><br><span class="line">      -machine pc-q35-2.4 \</span><br><span class="line">      -smp 2,cores=1 \</span><br><span class="line">      -usb -device usb-kbd -device usb-tablet \</span><br><span class="line">      -device isa-applesmc,osk=&quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot; \</span><br><span class="line">      -kernel ./enoch_rev2902_boot \</span><br><span class="line">      -smbios type=2 \</span><br><span class="line">      -device ich9-intel-hda -device hda-duplex \</span><br><span class="line">      -device ide-drive,bus=ide.2,drive=MacHDD \</span><br><span class="line">      -drive id=MacHDD,if=none,file=./mac_hdd.img \</span><br><span class="line">      -netdev tap,id=net0,ifname=tap0,script=no,downscript=no -device e1000-82545em,netdev=net0,id=net0,mac=52:54:00:c9:18:27 \</span><br><span class="line">      -monitor stdio \</span><br><span class="line">      -device ide-drive,bus=ide.0,drive=MacDVD \</span><br><span class="line">      -drive id=MacDVD,if=none,snapshot=on,file=./&apos;Install_macOS_Sierra_OS_X_10.12.iso&apos;</span><br><span class="line">      -vnc 0.0.0.0:0 -k en-us</span><br></pre></td></tr></table></figure><p>安装完，将MacDVD -device及ISO -drive配置注释掉，启动虚拟机。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/kvm-run-macos/macos_10.12.jpg" alt="macos_sierra"></p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>虚拟机可正常运行后，接下来最重要的工作是网络配置，使虚拟机可正常连接网络。</p><p>既想让虚拟机可连接外网（但不暴露给外网，外网不能直接访问虚拟机），又不影响主机的网络访问，比较简单的方式是使用TAP interfaces，TAP直接将二层以太帧发送给用户态程序，这正是虚拟网卡(vNIC)期望的工作方式。虚拟机的IP，可通过主机dnsmasq提供的DHCP服务自动获取，然后将虚拟机网络流量通过主机iptables SNAT转发到外网，实现虚拟机访问网络。虚拟机网络连接拓扑：</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/kvm-run-macos/macos-network.jpg" alt="network"></p><h3 id="网桥virbr0创建"><a href="#网桥virbr0创建" class="headerlink" title="网桥virbr0创建"></a>网桥virbr0创建</h3><p>创建持久网桥，这样主机重启后就不必重新配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /etc/sysconfig/network-scripts/ifcfg-virbr0 </span><br><span class="line">DEVICE=virbr0</span><br><span class="line">TYPE=Bridge</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=172.16.1.1</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure><h3 id="iptables-SNAT"><a href="#iptables-SNAT" class="headerlink" title="iptables SNAT"></a>iptables SNAT</h3><p>配置<code>/etc/sysconfig/iptables</code>添加NAT规则:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A POSTROUTING -s 172.16.1.0/24 ! -d 172.16.1.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>配置<code>/etc/sysctl.conf</code>开启IPv4转发功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><h3 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h3><p>配置dnsmasq，给虚拟机提供DHCP和DNS服务。</p><h3 id="虚拟机网卡配置"><a href="#虚拟机网卡配置" class="headerlink" title="虚拟机网卡配置"></a>虚拟机网卡配置</h3><p>将之前虚拟机启动脚本中的网卡配置，改成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-netdev tap,id=net100,ifname=tap100,script=/etc/qemu-ifup.sh,downscript=no -device e1000-82545em,netdev=net100,id=net100,mac=00:16:3e:eb:ca:65</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-netdev tap,id=net101,ifname=tap101,script=/etc/qemu-ifup.sh,downscript=no -device e1000-82545em,netdev=net101,id=net101,mac=00:16:3e:eb:ca:66</span><br></pre></td></tr></table></figure><p>注意虚拟网卡是e1000-82545em，不是e1000，否则虚拟机网卡无法正常工作。参见<a href="https://wiki.qemu.org/ChangeLog/2.1" target="_blank" rel="external">QEMU 2.1 Changelog</a>：</p><blockquote><p>More variants of the e1000 NIC are supported (e1000-82540em, e1000-82544gc, e1000-82545em). The default e1000 fails with versions of Mac OS X starting at 10.9, while the new e1000-82545em works with all versions of Mac OS X starting at 10.6.</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /etc/qemu-ifup.sh </span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">switch=virbr0</span><br><span class="line"></span><br><span class="line">echo &quot;$0: adding tap interface \&quot;$1\&quot; to bridge \&quot;$switch\&quot;&quot;</span><br><span class="line">ifconfig $1 0.0.0.0 up</span><br><span class="line">brctl addif $&#123;switch&#125; $1</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>启动虚拟机后，虚拟机就可正常访问网络了。</p><p>在使用过程中，发现一个问题，TAP的MAC地址是内核随机分配的，而网桥的MAC地址又是绑定到网桥上所有设备的MAC地址的最小值，这样如果有多台虚拟机同时运行，动态创建关闭虚拟机，会造成网桥MAC地址改变，进而会造成正在运行的虚拟机产生网络丢包，影响网络性能。下面用实验进行详细说明。</p><ul><li>创建虚拟机前virbr0 MAC地址：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ifconfig virbr0</span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr 00:00:00:00:00:00  </span><br><span class="line">          inet addr:172.16.1.1  Bcast:172.16.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::e0a8:9cff:fe32:c4fe/64 Scope:Link</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:956628 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:566603 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:474140424 (452.1 MiB)  TX bytes:1787345607 (1.6 GiB)</span><br></pre></td></tr></table></figure><ul><li>创建第一台虚拟机，virbr0和tap101 MAC地址：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ifconfig virbr0</span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr 62:93:B7:8A:03:B7  </span><br><span class="line">          inet addr:172.16.1.1  Bcast:172.16.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::e0a8:9cff:fe32:c4fe/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:956628 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:566605 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:474140424 (452.1 MiB)  TX bytes:1787345827 (1.6 GiB)</span><br><span class="line"></span><br><span class="line">$ ifconfig tap101</span><br><span class="line">tap101    Link encap:Ethernet  HWaddr 62:93:B7:8A:03:B7  </span><br><span class="line">          inet6 addr: fe80::6093:b7ff:fe8a:3b7/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:90 (90.0 b)</span><br></pre></td></tr></table></figure><p>虚拟机网卡：</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/kvm-run-macos/macos101-en0.png" alt="macos101-en0"></p><ul><li>在第一台虚拟机中，进行ping网络测试，同时启动第二台虚拟机。如果第二台虚拟机的TAP MAC地址小于第一台虚拟机TAP MAC地址，网桥virbr0 MAC地址会发生改变，第一台虚拟机中ping网络测试会产生丢包。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tap101    Link encap:Ethernet  HWaddr 62:93:B7:8A:03:B7  </span><br><span class="line">          inet6 addr: fe80::6093:b7ff:fe8a:3b7/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:14676 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:22129 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:1138569 (1.0 MiB)  TX bytes:30607004 (29.1 MiB)</span><br><span class="line"></span><br><span class="line">tap102    Link encap:Ethernet  HWaddr 2E:FA:07:80:C6:23  </span><br><span class="line">          inet6 addr: fe80::2cfa:7ff:fe80:c623/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:90 (90.0 b)</span><br><span class="line"></span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr 2E:FA:07:80:C6:23  </span><br><span class="line">          inet addr:172.16.1.1  Bcast:172.16.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::e0a8:9cff:fe32:c4fe/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:977654 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:581415 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:475446338 (453.4 MiB)  TX bytes:1830140398 (1.7 GiB)</span><br></pre></td></tr></table></figure><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/kvm-run-macos/macos101-ping.png" alt="macos101-ping"></p><p>虚拟机需要重新通过ARP探测网桥MAC地址，才能重新恢复正常网络访问。关闭第二台虚拟机，virbr0 MAC地址又会发生改变，再次造成第一台虚拟机网络丢包。</p><p>虚拟机内tcpdump抓包，注意看，MAC地址从<code>62:93:B7:8A:03:B7</code>变成<code>2E:FA:07:80:C6:23</code>。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/kvm-run-macos/macos101-tcpdump.png" alt="macos101-tcpdump"></p><p>一种解决方案是，将所有虚拟机的TAP MAC地址配置成同一个值，这样网桥MAC地址不会发生改变，也不影响虚拟机网络访问。修改/etc/qemu-ifup.sh:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /etc/qemu-ifup.sh </span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">switch=virbr0</span><br><span class="line"></span><br><span class="line">echo &quot;$0: adding tap interface \&quot;$1\&quot; to bridge \&quot;$switch\&quot;&quot;</span><br><span class="line">ifconfig $1 hw ether fe:ff:ff:ff:ff:ff</span><br><span class="line">ifconfig $1 0.0.0.0 up</span><br><span class="line">brctl addif $&#123;switch&#125; $1</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://qemu.weilnetz.de/doc/qemu-doc.html" target="_blank" rel="external">QEMU User Documentation</a></li><li><a href="http://www.linux-kvm.org/page/Networking" target="_blank" rel="external">QEMU Configuring Guest Networking</a></li><li><a href="https://www.redhat.com/archives/libvirt-users/2015-April/msg00149.html" target="_blank" rel="external">How does the libvirt deal with the vnet mac address</a></li><li><a href="http://backreference.org/2010/07/28/linux-bridge-mac-addresses-and-dynamic-ports/" target="_blank" rel="external">Linux bridge: MAC addresses and dynamic ports</a></li><li><a href="http://www.innervoice.in/blogs/2013/12/08/tap-interfaces-linux-bridge/" target="_blank" rel="external">Tap Interfaces and Linux Bridge</a></li><li><a href="https://goyalankit.com/blog/linux-bridge" target="_blank" rel="external">Linux Bridge - how it works</a></li><li><a href="https://en.wikipedia.org/wiki/TUN/TAP" target="_blank" rel="external">Wikipedia TUN/TAP</a></li><li><a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt" target="_blank" rel="external">Linux kernel TUN/TAP device driver</a></li><li><a href="http://xmodulo.com/how-to-configure-linux-bridge-interface.html" target="_blank" rel="external">How to configure a Linux bridge interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近尝试基于Xen运行macOS操作系统，之前已经有人做过类似的研究：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.osx86project.org/wiki/index.php/Snow_Leopard_Server_on_Xen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Snow Leopard Server on Xen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bisente.com/2011/03/15/macos-xen-snow-leopard-as-guest-on-a-xen-domu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MACOS XEN: SNOW LEOPARD AS GUEST ON A XEN DOMU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://groups.google.com/forum/#!msg/qubes-users/RiVntUzgJmY/rXMtXD3WKQAJ&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Qubes 3 MacOSX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然可正常运行，但缺少后续研究，也没有官方支持，所以目前为止Xen只能勉强运行老版本OSX操作系统。运行OSX系统，需要对Xen hypervisor进行修改，如支持MSR 0x35，OSX系统启动时需要据此确定CPU核心数和线程数，但是这个特性连Intel官方开发文档都没有明确说明，所以Xen官方拒绝将此修改合并到Xen主分支代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lists.xen.org/archives/html/xen-devel/2014-09/msg02524.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xen-devel PATCH x86/hvm: add support for MSR 0x35&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lists.xen.org/archives/html/xen-devel/2014-09/msg02525.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xen-devel PATCH x86/traps: hypervisor leaf 0x40000010 timing info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自己在本地修改Xen源码，虽然可安装、启动OSX-10.10系统，但还是遇到了其他问题，如外设模拟、系统驱动等，所以系统还是没法正常使用，只好作罢，转而投向更加活跃、有社区支持的&lt;a href=&quot;https://github.com/kholia/OSX-KVM&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OSX-KVM&lt;/a&gt;项目，基于KVM运行macOS系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://consen.github.io/categories/Virtualization/"/>
    
    
      <category term="KVM" scheme="https://consen.github.io/tags/KVM/"/>
    
      <category term="macOS" scheme="https://consen.github.io/tags/macOS/"/>
    
      <category term="TAP" scheme="https://consen.github.io/tags/TAP/"/>
    
      <category term="bridge" scheme="https://consen.github.io/tags/bridge/"/>
    
  </entry>
  
  <entry>
    <title>并发服务实现</title>
    <link href="https://consen.github.io/2017/12/13/concurrent-servers/"/>
    <id>https://consen.github.io/2017/12/13/concurrent-servers/</id>
    <published>2017-12-13T23:46:11.000Z</published>
    <updated>2018-01-04T13:57:44.583Z</updated>
    
    <content type="html"><![CDATA[<p>最近拜读了Eli Bendersky写的<a href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/" target="_blank" rel="external">Concurrent Servers</a>系列博客，作者由简单到复杂，由串行到并行，由多线程到事件驱动，再到第三方库对并发的实现，梳理了并发服务相关思想，在此对相关重点做一总结。</p><p>作者写就此文的目的是检验几种流行的并发模型，评判这些模型的伸缩性(scalability)和是否容易实现。作者自定义了一种简单的协议(protocol)，用于服务端与客户端交互，协议是有状态的(stateful)，服务端根据客户端发送的数据更改状态，并根据状态产生不同行为。</p><a id="more"></a><h2 id="A-sequential-server"><a href="#A-sequential-server" class="headerlink" title="A sequential server"></a>A sequential server</h2><p>串行服务，一次只能处理一个客户端请求，其他客户端只能等待，所以效率很低，这也促使引入更高效的并发模型。(我之前的一篇博客<a href="https://consen.github.io/2016/09/20/a-network-timeout-bug/">网络连接为什么超时了</a>就跟串行服务有关)</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/concurrent-servers/sequential-flow.png" alt=""></p><h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>并发实现的一种方法是多线程，这样服务端可同时处理多个客户端。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/concurrent-servers/concurrent-flow.png" alt=""></p><p>每一个客户端都新建一个线程，带来的问题是，客户端一多，线程会占用服务器大量内存，而且大量CPU时间用于线程上下文切换，甚至会引发安全问题，资源耗尽造成拒绝服务(DoS)攻击。所以需要对并发的客户端数量进行限制(rate-limiting)，比较流行的设计是线程池(thread pool)。</p><h3 id="Thread-pools"><a href="#Thread-pools" class="headerlink" title="Thread pools"></a>Thread pools</h3><p>线程池思想简单，却功能强大。服务端创建一个有多个线程的线程池，只有线程池中有空闲线程时，才会处理新的客户端请求。在面对高负载时，线程池也是一种优雅降级(graceful degradation)，服务端仍然能以一定速率提供正常服务，而不会资源耗尽停止服务。</p><h2 id="Event-driven"><a href="#Event-driven" class="headerlink" title="Event driven"></a>Event driven</h2><p>多线程并不是并发处理的唯一方式，另外一种常见的并发方法是事件驱动编程(event-driven programming)，即异步编程(asynchronous programming)。</p><h3 id="Blocking-vs-nonblocking-I-O"><a href="#Blocking-vs-nonblocking-I-O" class="headerlink" title="Blocking vs. nonblocking I/O"></a>Blocking vs. nonblocking I/O</h3><p>首先对比下阻塞I/O和非阻塞I/O，阻塞I/O是我们比较熟悉的I/O API工作方式，比如从一个socket接收数据，对recv的调用会阻塞，直到接收到数据。当把socket设置为非阻塞模式，对recv的调用会立即返回，即使没有接收到数据。</p><p>似乎我们可以通过非阻塞I/O来实现并发，同时处理多个客户端，只要轮询(polling)每个socket，检查是否收到了数据。但是在实际应用中，这种解决方案伸缩性较差，比如现在有1000个客户端需要并发处理，单单是遍历所有sockets就要花费很多时间，相当低效。其实操作系统内部是知道哪个socket收到了数据，我们不必扫描所有sockets，直接使用提供的API即可。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select允许在单线程中监控多个文件描述符，无需不必要的轮询。通过select，实现了I/O复用(I/O multiplexing)，在同一个线程中并发处理多个客户端，一个客户端处理完一些工作后，就切换到另一个客户端接着处理。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/concurrent-servers/multiplexed-flow.png" alt=""></p><p>然而select有一定的限制，一是可监控的文件描述符数量受限，一般最多为1024，二是性能较差，当select返回时，提供的信息只有可用文件描述的数量，具体是哪些文件描述符可用，还是需要遍历所有监控的文件描述符。因此现代并发服务实现已经很少用select了，转而使用更高效的其他API，如epoll。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll的高效之处在于直接返回所有可用的文件描述符，不必再去遍历所有文件描述符，这样就将找到可用文件描述符的时间复杂度从O(N)降到了O(1)。</p><h2 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h2><p>直接基于select或epoll实现并发服务，跨平台能力较差，<a href="http://libuv.org/" target="_blank" rel="external">libuv</a>做了一层抽象，提供高性能异步IO编程模型。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/concurrent-servers/libuv-architecture.png" alt=""></p><p>libuv的核心是事件循环(evevt loop)，用户只需要注册事件处理例程(event handlers)，即回掉函数(callback functions)，然后运行循环(loop)。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/concurrent-servers/libuv-loop_iteration.png" alt=""></p><p>基于libuv实现的事件驱动(event-driven)服务，在单线程中并发处理所有客户端，服务逻辑通过一系列的回掉函数实现，如果回掉函数的操作需要花费大量时间，会阻塞整个事件循环(event loop)，所以长时间运行的回掉函数是一大禁忌。</p><p>但是有些回掉操作确实需要花费大量时间，就需要将阻塞调用(blocking calls)转换成异步调用(asynchronous calls)，即利用线程池，libuv提供了相应的机制。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>最后作者以Redis为例，分析了其并发实现。Redis实现了自己的事件驱动库(event-driven library)，叫<a href="https://redis.io/topics/internals-rediseventlib" target="_blank" rel="external">ae</a>，既然有现成的libuv，为什么还要自己实现ae呢？Redis作者回答说，ae只有区区1K行左右的代码，专门为Redis设计，和Redis协同发展，只包含Redis需要的功能，而libuv有26K的代码，庞大又复杂，包含了很多Redis不需要的功能。这也为软件项目中的依赖处理提供了借鉴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近拜读了Eli Bendersky写的&lt;a href=&quot;https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concurrent Servers&lt;/a&gt;系列博客，作者由简单到复杂，由串行到并行，由多线程到事件驱动，再到第三方库对并发的实现，梳理了并发服务相关思想，在此对相关重点做一总结。&lt;/p&gt;
&lt;p&gt;作者写就此文的目的是检验几种流行的并发模型，评判这些模型的伸缩性(scalability)和是否容易实现。作者自定义了一种简单的协议(protocol)，用于服务端与客户端交互，协议是有状态的(stateful)，服务端根据客户端发送的数据更改状态，并根据状态产生不同行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://consen.github.io/categories/Linux/"/>
    
    
      <category term="Concurrency" scheme="https://consen.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>segfault段错误问题修复</title>
    <link href="https://consen.github.io/2017/11/28/qemu-nbd-segfault/"/>
    <id>https://consen.github.io/2017/11/28/qemu-nbd-segfault/</id>
    <published>2017-11-28T21:36:22.000Z</published>
    <updated>2017-12-05T09:44:08.951Z</updated>
    
    <content type="html"><![CDATA[<p>segfault段错误是软件开发中经常会遇到的错误，该错误是由非法内存访问造成的，如空指针引用；在只读内存区域进行写操作；访问受保护的内存区域等。在不同场景下，segfault的解决难度大不相同，比如有源代码并且segfault很容易复现，重新编译一个调试版可执行文件，用gdb调试马上就能定位问题。但是如果segfault很难复现，或者没有调式版可用呢？又如何去定位问题呢？</p><p>最近就在线上环境遇到一个qemu-ndb造成的segfault错误，影响很严重。qemu-nbd要用到nbd内核模块，segfault错误出现时，qemu-nbd相关进程卡主无响应，造成业务无法正常运行，甚至无法强制kill掉qemu-nbd进程，只能断电重启服务器使业务临时恢复正常运行。根据现象判断，qemu-nbd进程处于uninterruptible sleep状态，通过ps命令可以看出qemu-nbd进程的状态为D(uninterruptible sleep)。相较于interruptible sleep状态，uninterruptible sleep状态下的进程对信号没有响应，无法对它发送SIGKILL信号，也就无法kill掉，只能重启服务器。该状态出现一般是IO出了问题，必须从根本上解决该问题，才能避免一些不必要的麻烦。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep nbd</span><br><span class="line">root     13647  0.0  0.0 295388  7344 ?        Dsl  Nov23   0:00 /usr/local/lib/xen/bin/qemu-nbd -c /dev/nbd10 /tmp/vm.img</span><br></pre></td></tr></table></figure><p>在这种场景下，遇到了以下几个难点：</p><ol><li>难以复现，线上几十台服务器大约每隔1周有1~2台上qemu-nbd会出现segfault错误，几乎无法通过手工方式复现；</li><li>有源代码，但是在本地测试调式版qemu-nbd，性能极差，无法投入线上使用，否则影响线上业务正常运行；</li><li>线上运行的qemu-nbd在编译时加了<code>-O2 -fomit-frame-pointer</code>优化参数，增加了反汇编代码的分析难度；</li><li>线上运行的qemu-nbd符号表信息被strip掉了，进一步增加了反汇编代码的分析难度；</li><li>segfault错误出现时在/var/log/message中只有一行日志信息，没有堆栈等更详细的信息。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel: qemu-nbd[13647]: segfault at 100 ip 0000561c8817d1c7 sp 00007fc8f1ce9c00 error 4 in qemu-nbd[561c88107000+155000]</span><br></pre></td></tr></table></figure><p><strong>也就是说，只能通过这一行日志信息，加上qemu-nbd二进制文件和源代码，去定位具体哪一行代码造成了segfault。</strong></p><p>首先看下segfault日志的含义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-nbd[13647]                    可执行文件名[进程ID]</span><br><span class="line">at 100                             出错时访问的内存地址</span><br><span class="line">ip 0000561c8817d1c7                出错时的指令指针</span><br><span class="line">sp 00007fc8f1ce9c00                出错时的栈指针</span><br><span class="line">error 4                            错误码</span><br><span class="line">qemu-nbd[561c88107000+155000]      进程虚拟内存区域(VMA)对应的文件名[VMA起始地址+VMA大小]</span><br></pre></td></tr></table></figure><p>错误码的定义:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Page fault error code bits:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   bit 0 ==    0: no page found   1: protection fault</span></span><br><span class="line"><span class="comment"> *   bit 1 ==    0: read access     1: write access</span></span><br><span class="line"><span class="comment"> *   bit 2 ==    0: kernel-mode access  1: user-mode access</span></span><br><span class="line"><span class="comment"> *   bit 3 ==               1: use of reserved bit detected</span></span><br><span class="line"><span class="comment"> *   bit 4 ==               1: fault was an instruction fetch</span></span><br><span class="line"><span class="comment"> *   bit 5 ==               1: protection keys block access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> x86_pf_error_code &#123;</span><br><span class="line"></span><br><span class="line">    PF_PROT     =       <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    PF_WRITE    =       <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    PF_USER     =       <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    PF_RSVD     =       <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    PF_INSTR    =       <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    PF_PK       =       <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可见，错误码4(100)表示从用户态读时出现no page found。</p><p>生成反汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ objdump -d -M intel qemu-nbd &gt; qemu-nbd.asm</span><br></pre></td></tr></table></figure><p>有了以上信息，即可通过ip指令指针在反汇编代码中定位出错指令。指令地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000561c8817d1c7 - 0x561c88107000 = 0x761c7</span><br></pre></td></tr></table></figure><p>由于线上运行的qemu-nbd的符号信息被strip掉了（为了使发布的可执行文件尽可能小，并增加逆向难度，一般会将符号信息剔除掉），所以从反汇编代码中很难确定0x761c7指令地址到底对应的是源代码的哪一行。</p><p>不过万幸的是，当初编译xen时的编译环境还在（如果编译环境发生了改变，就只能重新编译，替换线上运行的qemu-nbd，等待问题复现），没有strip掉符号信息的qemu-nbd版本还在，位于<code>tools/qemu-xen-dir/qemu-nbd</code>，strip版本位于<code>dist/install/usr/local/lib/xen/bin/qemu-nbd</code> (线上环境的qemu-nbd就是使用的该二进制文件)。现在对比下非strip和strip版本的反汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ objdump -d -M intel tools/qemu-xen-dir/qemu-nbd &gt; qemu-nbd.asm</span><br><span class="line">$ objdump -d -M intel dist/install/usr/local/lib/xen/bin/qemu-nbd &gt; qemu-nbd-strip.asm</span><br><span class="line">$ vim -d qemu-nbd.asm qemu-nbd-strip.asm</span><br></pre></td></tr></table></figure><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/qemu-nbd-segfault/qemu-nbd-asm-rbx.png" alt="qemu-nbd-asm-rbx"></p><p>有符号信息对于定位源代码帮助非常大，strip版本函数入口信息都没了，定位出错函数无异于大海捞针。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/qemu-nbd-segfault/qemu-nbd-asm.png" alt="qemu-nbd-asm"></p><p>由汇编代码可以看出问题出在函数<code>bdrv_co_flush</code>，执行指令<code>mov    rax,QWORD PTR [rdx+0x100]</code>时出错，此时rdx为0，所以segfault日志信息中才有<code>at 100</code>。</p><p>进一步分析汇编代码，由指令<code>mov    rbx,rdi</code>确定rbx为函数<code>bdrv_co_flush</code>的第一个参数<code>BlockDriverState *bs</code>，根据数据结构<a href="http://xenbits.xen.org/gitweb/?p=qemu-xen.git;a=blob;f=include/block/block_int.h;h=1e939de4fe5a3b04b418edb4c108e82c3c93a0f8;hb=4220231eb22235e757d269722b9f6a594fbcb70f#l427" target="_blank" rel="external">struct BlockDriverState</a>及内存对齐（此处按8字节对齐，其中CoQueue为包含两个指针的结构体，所以占16字节），确定<code>[rbx+0x38]</code>为<code>bs-&gt;drv</code>即rdx，同理根据结构体<a href="http://xenbits.xen.org/gitweb/?p=qemu-xen.git;a=blob;f=include/block/block_int.h;h=1e939de4fe5a3b04b418edb4c108e82c3c93a0f8;hb=4220231eb22235e757d269722b9f6a594fbcb70f#l87" target="_blank" rel="external">struct BlockDriver</a>可推算出<code>[rdx+0x100]</code>为<code>bs-&gt;drv-&gt;bdrv_co_flush</code>。（由于qemu-xen源码一直在更新，分析源码时只能使用当初编译xen时使用的qemu-xen版本）</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/qemu-nbd-segfault/qemu-nbd-bs.png" alt="qemu-nbd-bs"></p><p>至此可以确定segfault是由于<code>bs-drv</code>为NULL造成的，即产生了空指针引用。函数代码位于<a href="http://xenbits.xen.org/gitweb/?p=qemu-xen.git;a=blob;f=block/io.c;h=420944d80db104188445e198ce45eb890fc6edfb;hb=4220231eb22235e757d269722b9f6a594fbcb70f#l2293" target="_blank" rel="external">block/io.c</a> 2293行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2292</span>     <span class="comment">/* Write back all layers by calling one driver function */</span></span><br><span class="line"><span class="number">2293</span>     <span class="keyword">if</span> (bs-&gt;drv-&gt;bdrv_co_flush) &#123;</span><br><span class="line"><span class="number">2294</span>         ret = bs-&gt;drv-&gt;bdrv_co_flush(bs);</span><br><span class="line"><span class="number">2295</span>         <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2296</span>     &#125;</span><br></pre></td></tr></table></figure><p>确定了引起segfault的具体代码，问题就很好解决了。其时qemu主分支就在最近对此问题已经有一定修复，<a href="https://git.qemu.org/?p=qemu.git;a=commitdiff;h=d470ad42acfc73c45d3e8ed5311a491160b4c100;hp=93bbaf03ff7fd490e823814b8f5d6849a7b71a64" target="_blank" rel="external">block: Guard against NULL bs-&gt;drv</a>。</p><p>如果能进一步深入分析引起<code>bs-&gt;drv</code>为空指针的原因，并能手动复现，找出攻击路径，即可发起DOS(拒绝服务)攻击。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;segfault段错误是软件开发中经常会遇到的错误，该错误是由非法内存访问造成的，如空指针引用；在只读内存区域进行写操作；访问受保护的内存区域等。在不同场景下，segfault的解决难度大不相同，比如有源代码并且segfault很容易复现，重新编译一个调试版可执行文件，用gdb调试马上就能定位问题。但是如果segfault很难复现，或者没有调式版可用呢？又如何去定位问题呢？&lt;/p&gt;
&lt;p&gt;最近就在线上环境遇到一个qemu-ndb造成的segfault错误，影响很严重。qemu-nbd要用到nbd内核模块，segfault错误出现时，qemu-nbd相关进程卡主无响应，造成业务无法正常运行，甚至无法强制kill掉qemu-nbd进程，只能断电重启服务器使业务临时恢复正常运行。根据现象判断，qemu-nbd进程处于uninterruptible sleep状态，通过ps命令可以看出qemu-nbd进程的状态为D(uninterruptible sleep)。相较于interruptible sleep状态，uninterruptible sleep状态下的进程对信号没有响应，无法对它发送SIGKILL信号，也就无法kill掉，只能重启服务器。该状态出现一般是IO出了问题，必须从根本上解决该问题，才能避免一些不必要的麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://consen.github.io/categories/Linux/"/>
    
    
      <category term="Xen" scheme="https://consen.github.io/tags/Xen/"/>
    
      <category term="segfault" scheme="https://consen.github.io/tags/segfault/"/>
    
  </entry>
  
  <entry>
    <title>使用串口调试Xen</title>
    <link href="https://consen.github.io/2017/07/26/debug-xen-with-serial-console/"/>
    <id>https://consen.github.io/2017/07/26/debug-xen-with-serial-console/</id>
    <published>2017-07-26T19:56:45.000Z</published>
    <updated>2018-01-04T13:59:17.952Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Xen的过程中，会遇到各种问题，掌握一些常见的调试技巧，对于解决问题能起到事半功倍的效果。网上一些Xen调试相关的资源：</p><ol><li><a href="https://wiki.xenproject.org/wiki/Debugging_Xen" target="_blank" rel="external">Debugging Xen</a></li><li><a href="https://wiki.xenproject.org/wiki/Xen_Serial_Console" target="_blank" rel="external">Xen Serial Console</a></li><li><a href="http://www-archive.xenproject.org/files/xensummit_intel09/xen-debugging.pdf" target="_blank" rel="external">Xen Debugging</a></li></ol><p>Xen hypervisor的运行信息写到了内存中，可以通过<code>xl dmesg</code>命令显示，并没有写入到日志文件，所以不太方便查看。如果遇到更严重的情况，Xen在启动阶段就出错了，则无法进入Dom0运行<code>xl dmesg</code>命令查看启动信息，只能通过串口查看。</p><p>使用串口调试Xen，需要两台物理机，通过串口线连接，一台运行Xen，另一台通过串口查看输出信息。</p><a id="more"></a><h2 id="串口线选择"><a href="#串口线选择" class="headerlink" title="串口线选择"></a>串口线选择</h2><p>串口线注意选择交叉线而不是直连线，一端用于发送，一端用于接收。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/debug-xen-with-serial-console/crossover.png" alt="crossover"></p><p>接口也要选对，看是公对公，母对母，还是公对母。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/debug-xen-with-serial-console/seriale_cable.jpg" alt="serial_cable"></p><h2 id="串口连通性测试"><a href="#串口连通性测试" class="headerlink" title="串口连通性测试"></a>串口连通性测试</h2><p>在对Xen进行串口配置之前，可以先测试下串口连通性。</p><p>查看串口信息，这里有两个串口（COM1和COM2），Linux下叫做ttyS0和ttyS1。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dmesg  | grep tty</span><br><span class="line">console [tty0] enabled</span><br><span class="line">00:03: ttyS1 at I/O 0x2f8 (irq = 3, base_baud = 115200) is a 16550A</span><br><span class="line">serial8250: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A</span><br></pre></td></tr></table></figure><p>在两台设备上同时运行<code>minicom -s</code>，配置串口。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/debug-xen-with-serial-console/minicom.png" alt="minicom"></p><p>配好后，输入任意字符，如果在另一台设备的<code>minicom</code>中能看到对应的输出，说明串口连接正常。</p><h2 id="Xen串口配置"><a href="#Xen串口配置" class="headerlink" title="Xen串口配置"></a>Xen串口配置</h2><p>在运行Xen的设备上，配置Grub开机启动项，Xen参数添加<code>loglvl=all guest_loglvl=all console=com2 com2=115200,8n1</code>，Dom0内核参数添加<code>console=hvc0</code>。</p><p>如果不想在串口中错过每一条信息，可在Xen参数添加<code>sync_console</code>，强制同步串口输出，当然这只适用于调试，因为需要将所有信息从串口输出，严重影响hypervisor性能，虚拟机会特别卡。</p><h2 id="串口调试Xen"><a href="#串口调试Xen" class="headerlink" title="串口调试Xen"></a>串口调试Xen</h2><p>Xen设备配置好后，在另一台设备上运行<code>minicom -s -C xen.log</code>，（<code>-C xen.log</code>将串口输出同时保存在xen.log文件，方便后续查看）,重启Xen设备。</p><p>Xen设备启动成功后，在串口上看到是Dom0，按6次<code>Ctrl-a</code>进入Xen。就可以看到虚拟机运行过程中，hypervisor的输出信息，可以更改Xen源码，添加更多printk()日志输出。也可以通过Xen debug keys获取相应信息，输入<code>h</code>，输出可用的kyes，输入key，输出对应信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(XEN) &apos;h&apos; pressed -&gt; showing installed handlers</span><br><span class="line">(XEN)  key &apos;%&apos; (ascii &apos;25&apos;) =&gt; trap to xendbg</span><br><span class="line">(XEN)  key &apos;*&apos; (ascii &apos;2a&apos;) =&gt; print all diagnostics</span><br><span class="line">(XEN)  key &apos;0&apos; (ascii &apos;30&apos;) =&gt; dump Dom0 registers</span><br><span class="line">(XEN)  key &apos;A&apos; (ascii &apos;41&apos;) =&gt; toggle alternative key handling</span><br><span class="line">(XEN)  key &apos;D&apos; (ascii &apos;44&apos;) =&gt; dump VT-x EPT tables</span><br><span class="line">(XEN)  key &apos;H&apos; (ascii &apos;48&apos;) =&gt; dump heap info</span><br><span class="line">(XEN)  key &apos;I&apos; (ascii &apos;49&apos;) =&gt; dump HVM irq info</span><br><span class="line">(XEN)  key &apos;M&apos; (ascii &apos;4d&apos;) =&gt; dump MSI state</span><br><span class="line">(XEN)  key &apos;N&apos; (ascii &apos;4e&apos;) =&gt; trigger an NMI</span><br><span class="line">(XEN)  key &apos;Q&apos; (ascii &apos;51&apos;) =&gt; dump PCI devices</span><br><span class="line">(XEN)  key &apos;R&apos; (ascii &apos;52&apos;) =&gt; reboot machine</span><br><span class="line">(XEN)  key &apos;V&apos; (ascii &apos;56&apos;) =&gt; dump iommu info</span><br><span class="line">(XEN)  key &apos;a&apos; (ascii &apos;61&apos;) =&gt; dump timer queues</span><br><span class="line">(XEN)  key &apos;c&apos; (ascii &apos;63&apos;) =&gt; dump ACPI Cx structures</span><br><span class="line">(XEN)  key &apos;d&apos; (ascii &apos;64&apos;) =&gt; dump registers</span><br><span class="line">(XEN)  key &apos;e&apos; (ascii &apos;65&apos;) =&gt; dump evtchn info</span><br><span class="line">(XEN)  key &apos;g&apos; (ascii &apos;67&apos;) =&gt; print grant table usage</span><br><span class="line">(XEN)  key &apos;h&apos; (ascii &apos;68&apos;) =&gt; show this message</span><br><span class="line">(XEN)  key &apos;i&apos; (ascii &apos;69&apos;) =&gt; dump interrupt bindings</span><br><span class="line">(XEN)  key &apos;m&apos; (ascii &apos;6d&apos;) =&gt; memory info</span><br><span class="line">(XEN)  key &apos;n&apos; (ascii &apos;6e&apos;) =&gt; NMI statistics</span><br><span class="line">(XEN)  key &apos;o&apos; (ascii &apos;6f&apos;) =&gt; dump iommu p2m table</span><br><span class="line">(XEN)  key &apos;q&apos; (ascii &apos;71&apos;) =&gt; dump domain (and guest debug) info</span><br><span class="line">(XEN)  key &apos;r&apos; (ascii &apos;72&apos;) =&gt; dump run queues</span><br><span class="line">(XEN)  key &apos;s&apos; (ascii &apos;73&apos;) =&gt; dump softtsc stats</span><br><span class="line">(XEN)  key &apos;t&apos; (ascii &apos;74&apos;) =&gt; display multi-cpu clock info</span><br><span class="line">(XEN)  key &apos;u&apos; (ascii &apos;75&apos;) =&gt; dump NUMA info</span><br><span class="line">(XEN)  key &apos;v&apos; (ascii &apos;76&apos;) =&gt; dump VT-x VMCSs</span><br><span class="line">(XEN)  key &apos;w&apos; (ascii &apos;77&apos;) =&gt; synchronously dump console ring buffer (dmesg)</span><br><span class="line">(XEN)  key &apos;z&apos; (ascii &apos;7a&apos;) =&gt; dump IOAPIC info</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://en.opensuse.org/How_to_Capture_Xen_Hypervisor_and_Kernel_Messages_using_a_Serial_Cable" target="_blank" rel="external">How to Capture Xen Hypervisor and Kernel Messages using a Serial Cable</a></li><li><a href="https://xenbits.xen.org/docs/unstable/misc/xen-command-line.html" target="_blank" rel="external">Xen Hypervisor Command Line Options</a></li><li><a href="https://www.decisivetactics.com/support/view?article=crossover-or-null-modem-vs-straight-through-serial-cable" target="_blank" rel="external">Crossover or “Null Modem” vs. Straight Through Serial Cable</a></li><li><a href="https://en.wikipedia.org/wiki/8-N-1" target="_blank" rel="external">8-N-1</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Xen的过程中，会遇到各种问题，掌握一些常见的调试技巧，对于解决问题能起到事半功倍的效果。网上一些Xen调试相关的资源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.xenproject.org/wiki/Debugging_Xen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Debugging Xen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.xenproject.org/wiki/Xen_Serial_Console&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xen Serial Console&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-archive.xenproject.org/files/xensummit_intel09/xen-debugging.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xen Debugging&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Xen hypervisor的运行信息写到了内存中，可以通过&lt;code&gt;xl dmesg&lt;/code&gt;命令显示，并没有写入到日志文件，所以不太方便查看。如果遇到更严重的情况，Xen在启动阶段就出错了，则无法进入Dom0运行&lt;code&gt;xl dmesg&lt;/code&gt;命令查看启动信息，只能通过串口查看。&lt;/p&gt;
&lt;p&gt;使用串口调试Xen，需要两台物理机，通过串口线连接，一台运行Xen，另一台通过串口查看输出信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://consen.github.io/categories/Virtualization/"/>
    
    
      <category term="Xen" scheme="https://consen.github.io/tags/Xen/"/>
    
      <category term="Serial Console" scheme="https://consen.github.io/tags/Serial-Console/"/>
    
  </entry>
  
  <entry>
    <title>Linux开发四件利器--Vim Tmux Git Zsh</title>
    <link href="https://consen.github.io/2017/02/14/four-linux-development-tools/"/>
    <id>https://consen.github.io/2017/02/14/four-linux-development-tools/</id>
    <published>2017-02-14T21:59:57.000Z</published>
    <updated>2017-11-15T13:13:01.977Z</updated>
    
    <content type="html"><![CDATA[<p>人与计算机交互，常见的方式有GUI（Graph User Interface，图形界面）、CLI（Command Line Interface，命令行）、TUI（Touch User Interface，触屏）等。交互方式也会影响软件开发，比如在Windows下，就可以使用强大的IDE — Visual Studio，而大多数Linux开发环境只提供了命令行界面，只能用命令行工具进行开发。</p><p>虽然命令行的学习成本比图形界面高，但熟练运用命令行后开发效率一点不比图形界面低，而且没有图形界面的干扰，更容易抓住技术的本质。下面就介绍Linux开发的四件利器，几乎是做Linux开发绕不开的工具。</p><a id="more"></a><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>Linux下的编辑器，<a href="http://www.vim.org/" target="_blank" rel="external">Vim</a>或<a href="https://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a>二选一，我选了普及率更高的Vim。Vim的学习曲线比较陡峭，但只要稍微克服下刚开始先入为主的抵触与害怕，你慢慢会发现Vim越用越有意思，越来越离不开Vim。如果你之前一直用的是图形界面的编辑器，用完Vim会对编辑器有个全新的认识，对文本的结构也会有全新认识，从文本到段落到句子到单词到字符，Vim能做到精确掌控。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/four-linux-development-tools/vim.png" alt="vim"></p><p>Vim的强大离不开灵活的配置及丰富的扩展，你可以将Vim配置成你喜欢的样子，我的Vim配置已放在GitHub，<a href="https://github.com/consen/dotfiles/blob/master/vim/vimrc" target="_blank" rel="external">dotfiles/vim/vimrc</a>。从配置可以看出，对于扩展插件管理我用的是<a href="https://github.com/junegunn/vim-plug/" target="_blank" rel="external">vim-plug</a>，几个比较有意思的扩展：</p><ul><li><a href="https://github.com/terryma/vim-multiple-cursors" target="_blank" rel="external">vim-multiple-cursord</a></li><li><a href="https://github.com/itspriddle/vim-stripper" target="_blank" rel="external">vim-stripper</a></li><li><a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="external">vim-gitgutter</a></li><li><a href="https://github.com/kien/rainbow_parentheses.vim" target="_blank" rel="external">rainbow_parentheses</a></li><li><a href="https://github.com/godlygeek/tabular" target="_blank" rel="external">tabular</a></li></ul><p>你也可以在<a href="http://vimawesome.com/" target="_blank" rel="external">Vim Awesome</a>查看各插件的排名。</p><p>Vim的各种使用技巧需要慢慢积累，如我之前的博客<a href="https://consen.github.io/2016/05/15/vim-tips/">《Vim Tips》</a>。几个比较精华的Vim学习资源：</p><ul><li><a href="https://vim.swaroopch.com/" target="_blank" rel="external">A Byte of Vim</a></li><li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki" target="_blank" rel="external">Vim Tips Wiki</a></li><li><a href="http://vimcasts.org/" target="_blank" rel="external">Vim Casts</a></li></ul><h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>如果你是远程连接到Linux服务器进行开发，一定遇到过下面几个问题：</p><ol><li>有时可能会同时进行多项操作，不得不打开多个窗口建立多个远程连接。</li><li>如果网络出现抖动，连接突然中断，又得重新建立连接，重新恢复之前的操作。</li><li>想在一个屏幕上不切换窗口，看到所有窗口的输出。</li></ol><p><a href="http://tmux.github.io/" target="_blank" rel="external">Tmux</a>（terminal multiplexer）很好地解决了上面的问题，只要建立一个远程连接，就可以开启多个终端，同时进行操作，一个查看文档，一个写代码，一个编译，一个运行程序。</p><p>我的Tmux配置，<a href="https://github.com/consen/dotfiles/blob/master/tmux/tmux.conf" target="_blank" rel="external">dotfiles/tmux/tmux.conf</a>，Tmux命令前置操作默认为Ctrl+b，我改成了Ctrl+a。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/four-linux-development-tools/tmux.png" alt="tmux"></p><p>常用的几个tmux命令：</p><ul><li>会话（session）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tmux new -s session-name          ; 新建会话</span><br><span class="line">$ tmux detach                       ; 断开会话</span><br><span class="line">$ tmux ls                           ; 列出会话</span><br><span class="line">$ tmux attach -t session-name       ; 连接会话，远程连接突然中断，再次连接后，attach到原先的会话，继续之前的操作</span><br></pre></td></tr></table></figure><ul><li>窗口（window）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+a c            ; 新建窗口</span><br><span class="line">Ctrl+a [0-9]        ; 切换窗口</span><br></pre></td></tr></table></figure><ul><li>窗格（pane）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+a -    ; 建立垂直窗格</span><br><span class="line">Ctrl+a |    ; 建立水平窗格</span><br><span class="line">Ctrl+a hjkl ; 切换窗格</span><br><span class="line">Ctrl+a z    ; 最大化窗格</span><br></pre></td></tr></table></figure><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>现在对代码的管理，已是<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>一统天下，又有<a href="https://github.com" target="_blank" rel="external">GitHub</a>加持，实在是解放了程序员，大大提升开发效率。</p><p>Git的命令很多，但日常用的20%都不到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone</span><br><span class="line">$ git pull</span><br><span class="line">$ git status</span><br><span class="line">$ git diff</span><br><span class="line">$ git add</span><br><span class="line">$ git commit -m &apos;&apos;</span><br><span class="line">$ git push</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">$ git checkout</span><br><span class="line">$ git merge</span><br></pre></td></tr></table></figure><h2 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h2><p>不推荐直接上手Zsh, 先从Bash玩起，因为你可以在开发环境下自己装个Zsh, 但是产品环境并不一定有Zsh，却一定有Bash。先从Bash开始搞懂Linux Shell的核心思想，比如至少对以下几点比较熟练：</p><ul><li>常用命令</li><li>Bash配置</li><li>常用快捷键</li><li>Bash脚本编写</li></ul><p>之后为了提高shell操作效率，就可以使用<a href="http://www.zsh.org/" target="_blank" rel="external">Zsh</a>了，当然离不开Zsh配置管理框架<a href="http://ohmyz.sh/" target="_blank" rel="external">Oh My Zsh</a>。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/four-linux-development-tools/zsh.png" alt="zsh"></p><p>我的Zsh配置，<a href="https://github.com/consen/dotfiles/blob/master/zsh/zshrc" target="_blank" rel="external">dotfiles/zsh/zshrc</a>。有个扩展鼎力推荐，它使Zsh的使用效率大幅提升，<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="external">zsh-autosuggestions</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人与计算机交互，常见的方式有GUI（Graph User Interface，图形界面）、CLI（Command Line Interface，命令行）、TUI（Touch User Interface，触屏）等。交互方式也会影响软件开发，比如在Windows下，就可以使用强大的IDE — Visual Studio，而大多数Linux开发环境只提供了命令行界面，只能用命令行工具进行开发。&lt;/p&gt;
&lt;p&gt;虽然命令行的学习成本比图形界面高，但熟练运用命令行后开发效率一点不比图形界面低，而且没有图形界面的干扰，更容易抓住技术的本质。下面就介绍Linux开发的四件利器，几乎是做Linux开发绕不开的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Toolbox" scheme="https://consen.github.io/categories/Toolbox/"/>
    
    
      <category term="Vim" scheme="https://consen.github.io/tags/Vim/"/>
    
      <category term="Tmux" scheme="https://consen.github.io/tags/Tmux/"/>
    
      <category term="Git" scheme="https://consen.github.io/tags/Git/"/>
    
      <category term="Zsh" scheme="https://consen.github.io/tags/Zsh/"/>
    
  </entry>
  
  <entry>
    <title>在指针中隐藏数据</title>
    <link href="https://consen.github.io/2017/01/07/hide-data-inside-pointers/"/>
    <id>https://consen.github.io/2017/01/07/hide-data-inside-pointers/</id>
    <published>2017-01-07T22:29:24.000Z</published>
    <updated>2017-11-15T16:29:14.557Z</updated>
    
    <content type="html"><![CDATA[<p>上周的博客文章<a href="https://consen.github.io/2016/12/30/upgrade-linux-kernel-module/">《Linux内核模块升级》</a>中，讲了通过升级Linux内核驱动模块xen-evtchn，解决掉一个Xen卡死问题，原因是port_user中port重用，触发kernel BUG。evtchn中port_user的实现，对指针的应用很巧妙：</p><ol><li>将指针存储在无符长整形（unsigned long）中。</li><li>将port是否enabled保存在无符长整形从低地址开始的第一个bit中。</li></ol><a id="more"></a><p>下面是从<a href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/drivers/xen/evtchn.c?h=v3.10.20" target="_blank" rel="external">evtchn.c</a>中抽取的关于port_user的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_user_data</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *port_user;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct per_user_data *<span class="title">get_port_user</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct per_user_data *)(port_user[port] &amp; ~<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_port_user</span><span class="params">(<span class="keyword">unsigned</span> port, struct per_user_data *u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    port_user[port] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">get_port_enabled</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> port_user[port] &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_port_enabled</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">bool</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">        port_user[port] |= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        port_user[port] &amp;= ~<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">evtchn_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    port_user = kcalloc(NR_EVENT_CHANNELS, <span class="keyword">sizeof</span>(*port_user), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (port_user == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言中对指针进行位操作是非法的，x64系统中指针占用8字节，unsigned long也占用8字节，所以将指针存储在unsigned long中，对unsigned long进行位操作。但是问题来了，将port是否enabled保存在第一个bit，那就得要求第一个bit在位操作之前一定为0。指针转换为unsigned long后，从低地址开始的第一个bit真的为0吗？</p><p>这就涉及到内存对齐了。CPU从内存中读写数据不是一次1字节，而是一次访问word size字节，一般为4字节或8字节，这样做当然是为了提升性能，所以一个变量在内存中的地址是可以整除1,2,4或8的，这就是内存对齐。如在x64系统下，unsigned long占用8字节，那么一个unsigned long变量在内存中的地址一定是可以被8整除，如地址可以为0x7fff4fcce908，但绝不会为0x7fff4fcce901，0x7fff4fcce907等不能被8整除的数值。</p><p><strong>任何能被8整除的整数，转换为二进制后，从低地址开始的3个bit一定为0。</strong></p><p>这个也很容易理解，并没有复杂的数学推理，整数8的二进制为<code>1000</code>，所以任何能被8整除的整数，转换为二进制后，从低地址开始的3个bit一定为0。举一反三下，任何能被4整除的整数，转换为二进制后，从低地址开始的2个bit一定为0，任何能被2整除的整数，转换为二进制后，从低地址开始的1个bit一定为0。4的二进制为<code>100</code>，2的二进制为<code>10</code>。</p><p>了解了内存对齐机制，上面port_user的实现就很好理解了。</p><p>其实，在Linux内核中，<strong>红黑树的实现就利用了指针隐藏数据</strong>。红黑树节点的定义为rb_node（<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/rbtree.h#n36" target="_blank" rel="external">include/linux/rbtree.h</a>）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure><p><code>__rb_parent_color</code>既用来存储父节点指针，也用来存储节点颜色，第一个bit为0表示红1表示黑。</p><p>再看下对父节点指针的访问（<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/rbtree.h#n48" target="_blank" rel="external">include/linux/rbtree.h</a>）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r)   ((struct rb_node *)((r)-&gt;__rb_parent_color &amp; ~3))</span></span><br></pre></td></tr></table></figure><p>对颜色的访问（<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/rbtree_augmented.h#n102" target="_blank" rel="external">include/linux/rbtree_augmented.h</a>）:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rb_color(pc)     ((pc) &amp; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_color(rb)       __rb_color((rb)-&gt;__rb_parent_color)</span></span><br></pre></td></tr></table></figure><hr><p>说到内存对齐，前段时间发过一条<a href="http://weibo.com/1996731561/Emg4Ytfty" target="_blank" rel="external">微博</a>，只有一行代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>         contentsz = (length + <span class="number">7</span>) &amp; ~<span class="number">7</span></span><br></pre></td></tr></table></figure><p>这行代码摘自Xen源码<a href="http://xenbits.xenproject.org/gitweb/?p=xen.git;a=blob;f=tools/python/xen/migration/libxl.py;hb=HEAD#l127" target="_blank" rel="external">tools/python/xen/migration/libxl.py</a>，很巧妙。简单讲下这行代码的用途，假设现在以8字节为单位存储数据，不足8字节的用0补齐，那么现在一段数据data的实际长度为length，存储后的长度则为contentsz，这样就可以算出总共填充了（contentsz - length）字节的0。如length为8，contentsz则为8，length为9，contentsz则为16。</p><hr><p>参考：</p><ul><li><a href="http://arjunsreedharan.org/post/105266490272/hide-data-inside-pointers" target="_blank" rel="external">Hide data inside pointers</a></li><li><a href="http://www.songho.ca/misc/alignment/dataalign.html" target="_blank" rel="external">Data Alignment</a></li><li><a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)" target="_blank" rel="external">Word (computer architecture)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周的博客文章&lt;a href=&quot;https://consen.github.io/2016/12/30/upgrade-linux-kernel-module/&quot;&gt;《Linux内核模块升级》&lt;/a&gt;中，讲了通过升级Linux内核驱动模块xen-evtchn，解决掉一个Xen卡死问题，原因是port_user中port重用，触发kernel BUG。evtchn中port_user的实现，对指针的应用很巧妙：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将指针存储在无符长整形（unsigned long）中。&lt;/li&gt;
&lt;li&gt;将port是否enabled保存在无符长整形从低地址开始的第一个bit中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://consen.github.io/categories/Linux/"/>
    
    
      <category term="pointer" scheme="https://consen.github.io/tags/pointer/"/>
    
      <category term="memory alignment" scheme="https://consen.github.io/tags/memory-alignment/"/>
    
      <category term="bitwise operation" scheme="https://consen.github.io/tags/bitwise-operation/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结，恭贺2017</title>
    <link href="https://consen.github.io/2016/12/31/goodbye-2016-hello-2017/"/>
    <id>https://consen.github.io/2016/12/31/goodbye-2016-hello-2017/</id>
    <published>2016-12-31T21:11:33.000Z</published>
    <updated>2017-11-15T13:13:01.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>工作两年多了，一直想在在技术上有所突破，<strong>从无到有</strong>创建一个项目，从设计到实现，代码到文档，模块到架构，前端到后端，开发到运维，完整搞一遍，提升用计算机解决问题的<strong>专业性、规范性、系统性、权威性</strong>，在今年实现了。Xenforce是我今年甚至工作以来的得意之作，不但为部门业务提供了强劲动力，自己的技术能力也得到提升，它将很多技术点都串联了起来。</p><a id="more"></a><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/goodbye-2016-hello-2017/xenforce_inspiration.png" alt="xenforce"></p><p>开发的过程中，我一直在问自己，“你写的代码或开发的产品你自己想用吗？你的代码能在部门内很好运行吗？能推广到公司其他部门吗？如果开源出去其他公司会用吗？”</p><p>遇到瓶颈是一件好事，说明知识经验累积到一定程度，到了爆发，到了再升一个台阶的时候了。虽然跨过一座山，还有另一座山。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>一直想建一个个人博客，在今年实现了，<a href="https://consen.github.io/">星夜前往</a>。虽然只写了15篇文章，还是收获颇多，最大的感受就是博客督促你开始关注技术细节，更加系统地学习掌握一个技术点。</p><p>之前对个人知识的管理都记录在云笔记上，Evernote CEO曾说“Evernote是你的第二大脑”，确实，工作以后越发觉得笔记的重要性了，一个问题可能会反反复复遇到多次，第一次解决的时间可能久一点，第二次解决只要查看下笔记花几分钟就能搞定，通过笔记把知识梳理地更加系统调理。而且，工作以后的笔记不同于学生时代的笔记，学生时代的笔记是要把笔记最终装在脑子里的，考试的时候不会让你去翻笔记，工作笔记是可以随时翻阅搜索的，是你的第二大脑。但是笔记毕竟是私有的，可以借助博客平台达到知识共享的目的，当然，一旦曝之于众，就不得不用更审慎的态度对待。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>要多读非技术类的书籍了。</p><ol><li>《解忧杂货店》</li><li>《白夜行》</li><li>《心理罪》</li><li>《人类简史》</li><li>《三体》</li></ol><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>只列出在电影院看的：</p><ol><li>《疯狂的动物城》</li><li>《火锅英雄》</li><li>《美国队长3》</li><li>《寒战2》</li><li>《谍影重重5》</li><li>《追凶者也》</li><li>《湄公河行动》</li><li>《驴得水》</li><li>《奇异博士》</li><li>《比利·林恩的中场战事》</li><li>《血战钢锯岭》</li></ol><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>我的歌单<a href="http://music.163.com/#/m/playlist?id=390149227&amp;userid=38676356" target="_blank" rel="external">《二零一六》</a>，每首歌都代表了当时的心情。</p><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>去了趟<a href="https://consen.github.io/2016/10/09/trip-to-japan/">日本</a>。</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>入手了<a href="https://consen.github.io/2016/06/13/why-hhkb/">HHKB Type-S</a>。</p><p>2016有收获，有遗憾，但是前行的脚步不能停歇，这个世界变化太快，你不得不奔跑起来，才不至于被变化甩太远。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h2&gt;&lt;p&gt;工作两年多了，一直想在在技术上有所突破，&lt;strong&gt;从无到有&lt;/strong&gt;创建一个项目，从设计到实现，代码到文档，模块到架构，前端到后端，开发到运维，完整搞一遍，提升用计算机解决问题的&lt;strong&gt;专业性、规范性、系统性、权威性&lt;/strong&gt;，在今年实现了。Xenforce是我今年甚至工作以来的得意之作，不但为部门业务提供了强劲动力，自己的技术能力也得到提升，它将很多技术点都串联了起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://consen.github.io/categories/Life/"/>
    
    
      <category term="annual report" scheme="https://consen.github.io/tags/annual-report/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核模块升级</title>
    <link href="https://consen.github.io/2016/12/30/upgrade-linux-kernel-module/"/>
    <id>https://consen.github.io/2016/12/30/upgrade-linux-kernel-module/</id>
    <published>2016-12-30T22:14:54.000Z</published>
    <updated>2017-11-15T16:27:39.701Z</updated>
    
    <content type="html"><![CDATA[<p>目前沙箱虚拟化是基于Xen实现的，沙箱集群大概运行一两个月，会有一台服务器出现Xen卡死的情况，xl命令无法使用，虚拟机无法创建，不得不重启服务器。在项目开发初期，通过重启来解决这样的问题是可以接受的，毕竟出错的概率不是很高，但如果不从根本上解决此问题，心里就像压了一块石头。这样的产品也不能卖给客户，如果你对客户说：“服务器卡死了没关系，重启下就好”，后果会怎样？</p><p>现在就彻底解决下这个问题。</p><a id="more"></a><p>Xen卡死后，<code>/var/log/messages</code>记录的日志中有个kernel BUG:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dec 23 00:51:38 w-xen09 kernel: ------------[ cut here ]------------</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: kernel BUG at drivers/xen/evtchn.c:264!</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: invalid opcode: 0000 [#3] SMP</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: Modules linked in: xt_physdev tun blktap xen_pciback xen_netback xen_blkback xen_gntalloc xen_gntdev xen_evtchn xenfs xen_privcmd bridge stp llc ipv6 ipt_MASQUERADE iptable_nat nf_conntrack_ipv4 nf_defrag_ipv4 nf_nat_ipv4 nf_nat nf_conntrack iptable_filter ip_tables sg serio_raw gpio_ich iTCO_wdt iTCO_vendor_support hpilo hpwdt coretemp freq_table mperf crc32_pclmul crc32c_intel ghash_clmulni_intel microcode pcspkr igb ptp pps_core lpc_ich ioatdma dca acpi_power_meter hwmon shpchp ext4 jbd2 mbcache sd_mod crc_t10dif aesni_intel ablk_helper cryptd lrw gf128mul glue_helper aes_x86_64 pata_acpi ata_generic ata_piix hpsa mgag200 ttm drm_kms_helper dm_mirror dm_region_hash dm_log dm_mod</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: CPU: 11 PID: 7959 Comm: xenstored Tainted: G      D      3.10.20-11.el6.centos.alt.x86_64 #1</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: Hardware name: HP ProLiant DL360p Gen8 HY, BIOS P71 08/02/2014</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: task: ffff881003548040 ti: ffff880ff03fa000 task.ti: ffff880ff03fa000</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RIP: e030:[&lt;ffffffffa03276f8&gt;]  [&lt;ffffffffa03276f8&gt;] evtchn_bind_to_user+0xb8/0xc0 [xen_evtchn]</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RSP: e02b:ffff880ff03fbe48  EFLAGS: 00010282</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RAX: ffff880ff1490668 RBX: 00000000000000cd RCX: 0000000000000000</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RDX: 0000000000000008 RSI: 00000000000000cd RDI: ffff881001655840</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RBP: ffff880ff03fbe78 R08: 0000000000001782 R09: ffff880ff03fbe88</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: R10: 0000000000000000 R11: 0000000000000206 R12: 0000000000000000</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: R13: 00000000000000cd R14: 0000000000000000 R15: 00007fffc9028ec0</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: FS:  00007f8bf955f740(0000) GS:ffff8810a8d60000(0000) knlGS:ffff8810a8d60000</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: CS:  e033 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: CR2: 00007ff95089a260 CR3: 0000001002e02000 CR4: 0000000000042660</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: Stack:</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: 00000000000000fb 0000000000000001 ffff880ff03fbe78 ffff881001655840</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: 0000000000000000 0000000000084501 ffff880ff03fbec8 ffffffffa032797e</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: 00000001f03f1782 ffffffff000000cd 0000000100001782 ffff880ff03fbf40</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: Call Trace:</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: [&lt;ffffffffa032797e&gt;] evtchn_ioctl+0x13e/0x304 [xen_evtchn]</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: [&lt;ffffffff811aa349&gt;] do_vfs_ioctl+0x89/0x350</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: [&lt;ffffffff811aa6b1&gt;] SyS_ioctl+0xa1/0xb0</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: [&lt;ffffffff810e00d6&gt;] ? __audit_syscall_exit+0x246/0x2f0</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: [&lt;ffffffff815fe719&gt;] system_call_fastpath+0x16/0x1b</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: Code: 74 19 85 c0 74 04 0f 0b eb fe 48 8b 05 b2 1b 00 00 4a c7 04 e8 00 00 00 00 eb c3 48 8d 75 d0 bf 03 00 00 00 e8 da 6f 02 e1 eb d7 &lt;0f&gt; 0b eb fe 0f 1f 40 00 55 48 89 e5 48 83 ec 40 48 89 5d d8 4c</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RIP  [&lt;ffffffffa03276f8&gt;] evtchn_bind_to_user+0xb8/0xc0 [xen_evtchn]</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: RSP &lt;ffff880ff03fbe48&gt;</span><br><span class="line">Dec 23 00:51:38 w-xen09 kernel: ---[ end trace b4e323e25997f660 ]---</span><br></pre></td></tr></table></figure><p>如果你了解Linux内核开发（不了解也没关系，可以参考下<a href="http://www.tldp.org/LDP/lkmpg/2.6/html/index.html" target="_blank" rel="external">The Linux Kernel Module Programming Guide</a>，这篇教程基于kernel-2.6编写的，如果你使用的内核版本比较新，如kernel-3.10，教程中一些代码可能会编译出错，因为新内核将某些模块重构了或者基于安全考虑将老版内核的一些功能屏蔽掉了），一定能马上看出这是Linux内核驱动模块xen_evtchn出了问题。</p><p>kernel BUG发生在<code>drivers/xen/evtchn.c:264</code>，目前使用的内核版本是kernel-3.10.20，所以得查看kernel-3.10.20中的<a href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/drivers/xen/evtchn.c?h=v3.10.20" target="_blank" rel="external">evtchn.c</a>代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">256</span>     <span class="comment">/*</span></span><br><span class="line"><span class="comment">257      * Ports are never reused, so every caller should pass in a</span></span><br><span class="line"><span class="comment">258      * unique port.</span></span><br><span class="line"><span class="comment">259      *</span></span><br><span class="line"><span class="comment">260      * (Locking not necessary because we haven't registered the</span></span><br><span class="line"><span class="comment">261      * interrupt handler yet, and our caller has already</span></span><br><span class="line"><span class="comment">262      * serialized bind operations.)</span></span><br><span class="line"><span class="comment">263      */</span></span><br><span class="line"><span class="number">264</span>     BUG_ON(get_port_user(port) != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>当<code>get_port_user(port) != NULL</code>时，BUG_ON()就打印出了上面的出错信息，包括寄存器和堆栈等信息。再看下<code>get_port_user()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">72</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">73  * Who's bound to each port?  This is logically an array of struct</span></span><br><span class="line"><span class="comment">74  * per_user_data *, but we encode the current enabled-state in bit 0.</span></span><br><span class="line"><span class="comment">75  */</span></span><br><span class="line"><span class="number">76</span> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *port_user;</span><br><span class="line"><span class="number">77</span> <span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(port_user_lock)</span></span>; <span class="comment">/* protects port_user[] and ring_prod */</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">79</span> <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct per_user_data *<span class="title">get_port_user</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span></span><br><span class="line"><span class="function">80 </span>&#123;</span><br><span class="line"><span class="number">81</span>     <span class="keyword">return</span> (struct per_user_data *)(port_user[port] &amp; ~<span class="number">1</span>);</span><br><span class="line"><span class="number">82</span> &#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，可以看出是port重用了。而最新的内核中，此问题已经被修复掉了，见提交记录<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/drivers/xen/evtchn.c?id=73cc4bb0c79eebe1f0e92b700d9fe8d1c9b061bb" target="_blank" rel="external">xen/evtchn: improve scalability by using per-user locks</a>。所以解决此问题可以升级内核，也可以只将内核模块xen_evtchn升级下，我们采用改动比较小的后者。</p><p>Linux内核模块是不能跨内核使用的，也就是说给A内核编译的内核模块无法在B内核上使用，除非采取一些tricks。比如我现在运行的内核版本是kernel-3.10.20，那么给kernel-2.6.32编译的内核模块就无法在kernel-3.10.20上使用，写个简单的demo说明下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">3.10.20-11.el6.centos.alt.x86_64</span><br></pre></td></tr></table></figure><p>最简单的内核模块，<a href="https://github.com/consen/demo/blob/master/linux/kernel-module/hello-2.6/hello.c" target="_blank" rel="external">hello world</a>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;   /* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   /* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;     /* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Goodbye, world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/consen/demo/blob/master/linux/kernel-module/hello-2.6/Makefile" target="_blank" rel="external">Makefile</a>文件，注意指定的版本号是kernel-2.6.32:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        make -C /lib/modules/2.6.32-220.el6.x86_64/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        make -C /lib/modules/2.6.32-220.el6.x86_64/build M=$(PWD) clean</span><br></pre></td></tr></table></figure><p>编译，生成hello.ko文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make -C /lib/modules/2.6.32-220.el6.x86_64/build M=/data1/home/xikangjie/github/demo/linux/kernel-module/hello-2.6 modules</span><br><span class="line">make[1]: Entering directory `/usr/src/kernels/2.6.32-220.el6.x86_64&apos;</span><br><span class="line">  CC [M]  /data1/home/xikangjie/github/demo/linux/kernel-module/hello-2.6/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /data1/home/xikangjie/github/demo/linux/kernel-module/hello-2.6/hello.mod.o</span><br><span class="line">  LD [M]  /data1/home/xikangjie/github/demo/linux/kernel-module/hello-2.6/hello.ko.unsigned</span><br><span class="line">  NO SIGN [M] /data1/home/xikangjie/github/demo/linux/kernel-module/hello-2.6/hello.ko</span><br><span class="line">make[1]: Leaving directory `/usr/src/kernels/2.6.32-220.el6.x86_64&apos;</span><br><span class="line">$ ls</span><br><span class="line">hello.c  hello.ko  hello.ko.unsigned  hello.mod.c  hello.mod.o  hello.o  Makefile  modules.order  Module.symvers</span><br></pre></td></tr></table></figure><p>插入内核模块，可以发现会出错，因为与当前内核版本不匹配，这个内核模块只能在kernel-2.6.32-220.el6.x86_64上正常运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo insmod ./hello.ko</span><br><span class="line">insmod: error inserting &apos;./hello.ko&apos;: -1 Invalid module format</span><br></pre></td></tr></table></figure><p>同时，<code>/var/log/messages</code>中对应的日志信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel: hello: disagrees about version of symbol module_layout</span><br></pre></td></tr></table></figure><p>将Makefile中的内核版本改为当前内核版本，<code>/lib/modules/$(shell uname -r)/build</code>，重新编译下，hello.ko就可正常加载了，同时<code>/var/log/messages</code>也输出了<code>Hello, world</code>。</p><p>使用的是kernel-3.10.20，最好就在kernel-3.10.20的开发环境下将新版xen_evtchn重新编译下。需要注意的是，如果新版xen_evtchn使用了新内核提供的一些功能，是无法在kernel-3.10.20上编译的，只能使用新版内核开发环境。所以只需要拿到修复了Xen卡死问题的evtchn.c代码即可，不需要是最新，我们选用提交<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/drivers/xen/evtchn.c?id=af09d1a73aed4e83ee095f2dabdc09386e31f2ea" target="_blank" rel="external">xen: remove deprecated IRQF_DISABLED</a>中的<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/xen/evtchn.c?id=af09d1a73aed4e83ee095f2dabdc09386e31f2ea" target="_blank" rel="external">evtchn.c</a>代码，既将Xen卡死问题解决了，又没有使用新版内核功能，可以在kernel-3.10.20上编译。</p><p>然后安装当前内核kernel-3.10.20的开发环境，即一堆头文件，在CentOS下是kernel-devel-3.10.20-11.el6.centos.alt.x86_64.rpm：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum info kernel-devel-3.10.20-11.el6.centos.alt.x86_64</span><br><span class="line">Installed Packages</span><br><span class="line">Name        : kernel-devel</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 3.10.20</span><br><span class="line">Release     : 11.el6.centos.alt</span><br><span class="line">Size        : 32 M</span><br><span class="line">Repo        : installed</span><br><span class="line">Summary     : Development package for building kernel modules to match the kernel.</span><br><span class="line">URL         : http://www.kernel.org/</span><br><span class="line">License     : GPLv2</span><br><span class="line">Description : This package provides the kernel header files and makefiles</span><br><span class="line">            : sufficient to build modules against the kernel package.</span><br></pre></td></tr></table></figure><p>安装好后会有目录<code>/usr/src/kernels/3.10.20-11.el6.centos.alt.x86_64/</code>，而且可以发现当前内核版本中/lib/modules/3.10.20-11.el6.centos.alt.x86_64/build链接也正常显示了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build -&gt; ../../../usr/src/kernels/3.10.20-11.el6.centos.alt.x86_64</span><br></pre></td></tr></table></figure><p>接着编写Makefile：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-m += xen-evtchn.o</span><br><span class="line">xen-evtchn-objs := evtchn.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br></pre></td></tr></table></figure><p>运行<code>make</code>命令编译，生成内核模块<code>xen-evtchn.ko</code>，拷贝到/lib/modules/3.10.20-11.el6.centos.alt.x86_64/kernel/drivers/xen/目录下，将老版<code>xen-evtchn.ko</code>覆盖（以防万一，可以将老版<code>xen-evtchn.ko</code>先备份下），<code>reboot</code>重启系统。</p><hr><p>参考：</p><ul><li><a href="http://www.tldp.org/LDP/lkmpg/2.6/html/index.html" target="_blank" rel="external">The Linux Kernel Module Programming Guide</a></li><li><a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="external">Linux Kernel Makefiles</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前沙箱虚拟化是基于Xen实现的，沙箱集群大概运行一两个月，会有一台服务器出现Xen卡死的情况，xl命令无法使用，虚拟机无法创建，不得不重启服务器。在项目开发初期，通过重启来解决这样的问题是可以接受的，毕竟出错的概率不是很高，但如果不从根本上解决此问题，心里就像压了一块石头。这样的产品也不能卖给客户，如果你对客户说：“服务器卡死了没关系，重启下就好”，后果会怎样？&lt;/p&gt;
&lt;p&gt;现在就彻底解决下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://consen.github.io/categories/Linux/"/>
    
    
      <category term="Xen" scheme="https://consen.github.io/tags/Xen/"/>
    
      <category term="kernel" scheme="https://consen.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>升级Xen 4.5到Xen 4.8</title>
    <link href="https://consen.github.io/2016/12/16/upgrade-xen45-to-xen48/"/>
    <id>https://consen.github.io/2016/12/16/upgrade-xen45-to-xen48/</id>
    <published>2016-12-16T21:13:09.000Z</published>
    <updated>2017-11-15T16:06:06.953Z</updated>
    
    <content type="html"><![CDATA[<p>Xen官方上周发布了Xen 4.8, <a href="https://blog.xenproject.org/2016/12/07/whats-new-with-xen-project-hypervisor-4-8/" target="_blank" rel="external">What’s New with Xen Project Hypervisor 4.8?</a>，添加了很多新功能，如<a href="https://wiki.xenproject.org/wiki/Credit2_Scheduler_Development" target="_blank" rel="external">Credit2</a>调度器正式发布。Xenforce目前使用的是Xen 4.5，从性能、稳定性、功能等几方面考虑，决定升级到Xen 4.8。</p><a id="more"></a><p>虽然Xenforce在设计实现之初就考虑到向前兼容Xen，以方便升级Xen，但实际升级到Xen 4.8时还是遇到了一些问题，不过都很好地解决了。升级完后，简单测试了下，设备CPU24核、内存64G、机械硬盘、快照1G，通过快照恢复一台虚拟机只需要3秒左右，而在Xen 4.5上需要6秒左右，Xenforce性能大幅提升，沙箱整体性能也得到提升。如果继续使用Xen 4.5，要提升性能就不得不升级硬件，如CPU 32核或快照存放在固态硬盘。升级到Xen 4.8，解决了快照加载的性能瓶颈，省去了硬件升级开销。</p><p>升级流程：</p><ul><li>下载源码包 <a href="https://xenproject.org/downloads/xen-archives/xen-project-48-series/xen-project-480.html" target="_blank" rel="external">Xen Project 4.8.0</a>。</li><li>按照README中的说明，安装依赖包，编译出错基本都是因为依赖包安装有问题。</li><li>配置，编译。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译成功会生成dist文件夹，此文件夹可以直接拷贝到其他设备上，进行安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls dist </span><br><span class="line">COPYING  install  install.sh  README</span><br></pre></td></tr></table></figure><ul><li>安装，运行dist/install.sh脚本，如果安装在<code>/usr/local</code>目录下，运行<code>ldconfig /usr/local/lib</code>命令加载动态链接库。</li><li>配置开机启动项，因为是从Xen 4.5升级过来的，直接沿用之前的<code>grub</code>配置即可，当然，如果想使用<code>Credit2</code>调度器，得在grub配置中添加<code>sched=credit2</code>，详见<a href="http://xenbits.xen.org/docs/unstable/misc/xen-command-line.html" target="_blank" rel="external">Xen Hypervisor Command Line Options</a></li><li>重启设备。重启完成后，运行<code>xl info</code>命令，查看Xen版本。</li></ul><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/upgrade-xen45-to-xen48/xen4.8.png" alt="xen48"></p><p>因为之前Xenforce是在Xen 4.5上制作的虚拟机快照，升级到Xen 4.8后，快照恢复出错。Xen从4.6版本开始，快照采用了新的格式<a href="https://xenbits.xen.org/docs/unstable/features/migration.html" target="_blank" rel="external">Migration V2</a>，当然，官方也提供了工具<code>convert-legacy-stream</code>将老版快照升级到新版。</p><p>先安装依赖，进入Xen 4.8源码的<code>tools/python</code>目录，运行命令<code>python setup.py install</code>。可运行<code>convert-legacy-stream -h</code>查看使用说明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert-legacy-stream -i vm.checkpoint.45 -o vm.checkpoint -w 64 -g hvm -f libxl -x -v</span><br></pre></td></tr></table></figure><p>遗憾的是转换后快照依然恢复出错，问题出在显卡上。不得不仔细研究了下Migration V2格式，参见<a href="https://xenbits.xen.org/docs/unstable/specs/libxc-migration-stream.html" target="_blank" rel="external">LibXenCtrl Domain Image Format</a>和<a href="https://xenbits.xen.org/docs/unstable/specs/libxl-migration-stream.html" target="_blank" rel="external">LibXenLight Domain Image Format</a>，最终用了一个小trick将问题解决，避免了对Xenforce做大幅改动。想起了传说中当年TK教主将一个损坏的压缩包，一个字节一个字节修复。当然，要从根本上解决此问题，还需把Xen对qemu的使用，以及快照中qemu状态保存的内容及格式，做更深入探究。</p><p>自此，Xen从4.5升级到4.8，Xenforce也无缝升级，平滑过渡。</p><hr><p>参考：</p><ul><li><a href="https://blog.xenproject.org/2016/12/07/whats-new-with-xen-project-hypervisor-4-8/" target="_blank" rel="external">What’s New with Xen Project Hypervisor 4.8?</a></li><li><a href="https://xenbits.xen.org/docs/unstable/specs/libxc-migration-stream.html" target="_blank" rel="external">LibXenCtrl Domain Image Format</a></li><li><a href="https://xenbits.xen.org/docs/unstable/specs/libxl-migration-stream.html" target="_blank" rel="external">LibXenLight Domain Image Format</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xen官方上周发布了Xen 4.8, &lt;a href=&quot;https://blog.xenproject.org/2016/12/07/whats-new-with-xen-project-hypervisor-4-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What’s New with Xen Project Hypervisor 4.8?&lt;/a&gt;，添加了很多新功能，如&lt;a href=&quot;https://wiki.xenproject.org/wiki/Credit2_Scheduler_Development&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Credit2&lt;/a&gt;调度器正式发布。Xenforce目前使用的是Xen 4.5，从性能、稳定性、功能等几方面考虑，决定升级到Xen 4.8。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://consen.github.io/categories/Virtualization/"/>
    
    
      <category term="Xen" scheme="https://consen.github.io/tags/Xen/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程端口转发</title>
    <link href="https://consen.github.io/2016/11/22/ssh-remote-port-forwarding/"/>
    <id>https://consen.github.io/2016/11/22/ssh-remote-port-forwarding/</id>
    <published>2016-11-22T19:04:45.000Z</published>
    <updated>2017-11-15T16:03:51.866Z</updated>
    
    <content type="html"><![CDATA[<p>自从开发完Xenforce+XenforceHub，虚拟机镜像部署变得异常简单，直接在要部署镜像的服务器上运行<code>xenforce pull</code>命令即可将需要的镜像从XenforceHub下载到本地，镜像可直接使用，无需更改配置，而且<code>xenforce pull</code>命令还会处理好镜像依赖，将依赖的镜像也下载下来。镜像部署变得完美，一切变得自动化，一切按照理想的方式工作着。</p><a id="more"></a><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/ssh-remote-port-forwarding/pull.png" alt=""></p><p>但是，因业务原因，一部分服务器部署在隔离网，导致服务器无法访问XenforceHub，无法使用<code>xenforce pull</code>命令部署镜像，一夜回到解放前，即使有<code>scp</code>、<code>rsync</code>、<code>nc</code>等一些优秀工具，可以借助用来手动同步镜像，还是太麻烦，程序猿懒起来，自己都害怕。最理想的方式还是用<code>xenforce pull</code>部署镜像，即使服务器在隔离网内。程序猿的首要任务是把不可能变得可能，把复杂变得简单，把低效变得高效。</p><p>隐隐约约想起当初学SSH的时候，SSH有个很精妙的用法，比如A、B两台服务器之间要实现互通，但是现在A可以访问B，B却不能访问A，那么B怎样访问A呢？可以借助SSH的远程端口转发功能。今天仔细研究了下，果然派上了用场。</p><p>以服务器server1为例，XenforceHub服务器可以访问server1，但是server1无法访问XenforceHub，在XenforceHub服务器上运行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 9000:localhost:9000 xikangjie@server1</span><br></pre></td></tr></table></figure><p>这样，在服务器server1上访问localhost:9000，就相当于访问XenforceHub:9000，又可以愉快地用命令<code>xenforce pull</code>部署镜像了。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/ssh-remote-port-forwarding/pull2.gif" alt=""></p><hr><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战 SSH 端口转发</a></li><li><a href="http://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html" target="_blank" rel="external">SSH Tunnel - Local and Remote Port Forwarding Explained With Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从开发完Xenforce+XenforceHub，虚拟机镜像部署变得异常简单，直接在要部署镜像的服务器上运行&lt;code&gt;xenforce pull&lt;/code&gt;命令即可将需要的镜像从XenforceHub下载到本地，镜像可直接使用，无需更改配置，而且&lt;code&gt;xenforce pull&lt;/code&gt;命令还会处理好镜像依赖，将依赖的镜像也下载下来。镜像部署变得完美，一切变得自动化，一切按照理想的方式工作着。&lt;/p&gt;
    
    </summary>
    
      <category term="Toolbox" scheme="https://consen.github.io/categories/Toolbox/"/>
    
    
      <category term="SSH" scheme="https://consen.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>日本之行</title>
    <link href="https://consen.github.io/2016/10/09/trip-to-japan/"/>
    <id>https://consen.github.io/2016/10/09/trip-to-japan/</id>
    <published>2016-10-09T17:07:04.000Z</published>
    <updated>2017-11-15T13:13:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>按照计划，十一假期去了日本旅行，行程包括大阪、京都、神户、奈良、冲绳。</p><p>刚去第一天，日本就给我留下了深刻印象，那种闲适的感觉，慢慢体会，真想一直待下去。</p><a id="more"></a><ul><li>干净整洁，空气清新，日本的干净是出了名的，街上几乎见不到垃圾。</li><li>建筑布局利用好每一寸空间，小巧玲珑，比如很多自动扶梯只能一人通过，日本人来中国旅行一定会觉得什么都很大气。</li><li>日本人很友好，素质比较高，随便进个餐馆，点菜可以用英文，服务员能听懂。</li><li>日本消费水平比中国高，从地铁公交出租车花费就能看出。</li><li>饮食做得精致，小碗小碟，吃完大概七八分饱。</li><li>随处可见自动售货机，一瓶矿泉水100多日元。</li><li>街上能看到很多男的穿黑西装白衬衫，一看就是上班族，女的化妆抹了腮红。</li></ul><p>然毕竟异国他乡，如秋水浮萍，还是会想家，待了一周就想回去了。</p><p>大阪城</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/daban.jpg" alt=""></p><p>有幸在大阪城一个剑术馆看到了日本剑术比赛</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/daban2.JPG" alt=""></p><p>大阪梅田空中瞭望台，140米高，观看夜景十分漂亮</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/daban_meitian.JPG" alt=""></p><p>大阪摩天轮上拍到的</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/daban_motianlun.JPG" alt=""></p><p>京都清水寺</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/jingdu.JPG" alt=""></p><p>抓拍到几位穿和服的日本女士，很有感觉</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/jingdu2.JPG" alt=""></p><p>奈良公园</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/nailiang.JPG" alt=""></p><p>可以喂鹿</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/nailiang2.JPG" alt=""></p><p>神户塔</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/shenhu.JPG" alt=""></p><p>冲绳琉球王国遗迹</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/trip-to-japan/chongsheng.JPG" alt=""></p><p>多出去走走，心中才能装下更大的世界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照计划，十一假期去了日本旅行，行程包括大阪、京都、神户、奈良、冲绳。&lt;/p&gt;
&lt;p&gt;刚去第一天，日本就给我留下了深刻印象，那种闲适的感觉，慢慢体会，真想一直待下去。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://consen.github.io/categories/Life/"/>
    
    
      <category term="Japan" scheme="https://consen.github.io/tags/Japan/"/>
    
      <category term="Trip" scheme="https://consen.github.io/tags/Trip/"/>
    
  </entry>
  
  <entry>
    <title>网络连接为什么超时了</title>
    <link href="https://consen.github.io/2016/09/20/a-network-timeout-bug/"/>
    <id>https://consen.github.io/2016/09/20/a-network-timeout-bug/</id>
    <published>2016-09-20T21:34:21.000Z</published>
    <updated>2017-11-15T15:53:53.963Z</updated>
    
    <content type="html"><![CDATA[<p>在cuckoo上测试我的xenforce，任务运行结果出现大量timeout错误，虽然以前也遇到过这个问题，但没当回事放过去了，现在有了xenforce还出现这种问题，是可忍孰不可忍，今天就认真排查下这个问题，消灭这只bug。</p><p>Bug现象是这样的，任务运行超时，错误日志有两种：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-09-20 14:08:58,540 [lib.cuckoo.core.scheduler] ERROR: vm-111: the guest initialization hit the critical timeout, analysis aborted.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-09-20 14:04:27,790 [lib.cuckoo.core.guest] DEBUG: vm-117: error retrieving status: timed out</span><br><span class="line">2016-09-20 14:04:28,799 [lib.cuckoo.core.scheduler] ERROR: The analysis hit the critical timeout, terminating.</span><br></pre></td></tr></table></figure><p>还有另外一种情况，没错误，但运行时间也超出正常值，时间主要消耗在这里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-09-20 19:06:52,752 [lib.cuckoo.core.guest] DEBUG: vm-103: waiting for status 0x0001</span><br><span class="line">2016-09-20 19:08:52,803 [lib.cuckoo.core.guest] DEBUG: vm-103: not ready yet</span><br></pre></td></tr></table></figure><p>总之，是访问虚拟机内agent.py提供的XMLRPC服务出现了超时问题。Why？为什么会超时？这影响的因素就太多了，只能一条条排除。</p><p>首先排除掉网络配置问题，xenforce在网络配置上做了优化，虚拟机快照恢复后，立马自动配置IP地址，可正常访问网络。观察日志，以及虚拟机内检测包和外部resultserver的正常通信也证实了我的想法。</p><p>是虚拟机环境问题导致的吗？虚拟机是通过快照恢复的，也就是说环境都是一样的，先排除掉。</p><p>既然是网络连接问题，先在主机上看下网络连接(8000是agent.py提供的XMLRPC服务端口，这里只列出了部分netstat输出结果)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># netstat -anp | grep :8000</span><br><span class="line">tcp        0      0 172.16.1.1:53033            172.16.1.108:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:37476            172.16.1.122:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:36381            172.16.1.110:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:50635            172.16.1.112:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:50222            172.16.1.104:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:34851            172.16.1.103:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:46671            172.16.1.121:8000           ESTABLISHED 32445/tcpdump       </span><br><span class="line">tcp        0      0 172.16.1.1:53098            172.16.1.113:8000           ESTABLISHED 30667/tcpdump       </span><br><span class="line">tcp        0      0 172.16.1.1:46680            172.16.1.121:8000           ESTABLISHED 336/tcpdump         </span><br><span class="line">tcp        0      0 172.16.1.1:44107            172.16.1.123:8000           ESTABLISHED 32559/tcpdump       </span><br><span class="line">tcp        0      0 172.16.1.1:53634            172.16.1.116:8000           CLOSE_WAIT  336/tcpdump</span><br></pre></td></tr></table></figure><p>像CLOSE_WAIT, TIME_WAIT这种状态，大量出现一般是有问题的。另外，还有<strong>一个更有意思的现象</strong>，这些网络连接为什么显示是<code>tcpdump</code>进程建立的？Why？<code>tcpdump</code>就一个抓包进程，怎么会去访问XMLRPC服务。哦？哦！<strong><code>tcpdump</code>进程是以子进程形式启动的，继承了父进程建立的网络连接，所以才会有上面的显示。</strong></p><p>直觉问题就出在<code>tcpdump</code>。</p><p>关掉抓包模块，跑了一遍测试，没有timeout错误，又跑了一遍，仍然没有。:)</p><p><code>tcpdump</code>进程是用<code>subprocess</code>模块启动的，将<code>subprocess.Popen()</code>的<code>close_fds</code>参数设置为<code>True</code>，子进程启动时，关闭从父进程继承的文件描述符。跑了一遍测试，没有timeout错误，又跑了一遍，仍然没有。:)</p><p>接着排查。</p><p>观察发现当tcpdump进程继承的网络连接状态显示为ESTABLISHED时，虚拟机内的agent.py就会卡住，对外面的请求没有响应。如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp        0      0 172.16.1.1:44727            172.16.1.121:8000           ESTABLISHED 32445/tcpdump</span><br></pre></td></tr></table></figure><p>172.16.1.121这台虚拟机就会出现问题，agent.py卡住，长时间没响应，于是外面访问时出现超时问题。在虚拟机内部观察netstat状态：</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/agent_netstat.png" alt="netstat"></p><p>将对应的tcpdump进程手动kill掉，ESTABLISHED连接状态消失，agent.py恢复正常，可正常响应请求。</p><p>问题来了，要找到根本原因得回答下面的问题：</p><ol><li>ESTABLISHED，CLOSE_WAIT状态是怎么出现的？</li><li>tcpdump进程继承的连接为什么会导致这些状态出现？</li><li>这些状态出现时，agent.py为什么会卡住没响应？</li></ol><hr><p>(2016.09.21 10:34更新)</p><p>先回答问题3， Python的SimpleXMLRPCServer是单线程的，串行执行请求，也就是说每次只能处理一个请求，当有请求正在处理，新的请求会阻塞住，就会出现agent.py卡住没响应的现象。</p><p>写个简单的demo测试下：</p><p><a href="https://github.com/consen/demo/blob/master/python/library/SimpleXMLRPCServer/function_server.py" target="_blank" rel="external">function_server.py</a>，提供一个简单的XMLRPC服务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up logging</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">server = SimpleXMLRPCServer((<span class="string">'localhost'</span>, <span class="number">9090</span>), logRequests=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expose a function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_contents</span><span class="params">(dir_name)</span>:</span></span><br><span class="line">    logging.debug(<span class="string">'list_contents(%s)'</span>, dir_name)</span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> os.listdir(dir_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_contents2</span><span class="params">(dir_name)</span>:</span></span><br><span class="line">    logging.debug(<span class="string">'list_contents(%s)'</span>, dir_name)</span><br><span class="line">    <span class="keyword">return</span> os.listdir(dir_name)</span><br><span class="line"></span><br><span class="line">server.register_function(list_contents)</span><br><span class="line">server.register_function(list_contents2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Use Control-C to exit'</span></span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Exiting'</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/consen/demo/blob/master/python/library/SimpleXMLRPCServer/function_client.py" target="_blank" rel="external">function_client.py</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpclib</span><br><span class="line"></span><br><span class="line">proxy = xmlrpclib.ServerProxy(<span class="string">'http://localhost:9090'</span>)</span><br><span class="line"><span class="keyword">print</span> proxy.list_contents(<span class="string">'./'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/consen/demo/blob/master/python/library/SimpleXMLRPCServer/function_client2.py" target="_blank" rel="external">function_client2.py</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpclib</span><br><span class="line"></span><br><span class="line">proxy = xmlrpclib.ServerProxy(<span class="string">'http://localhost:9090'</span>)</span><br><span class="line"><span class="keyword">print</span> proxy.list_contents2(<span class="string">'./'</span>)</span><br></pre></td></tr></table></figure><p>先启动function_client.py，由于list_contents()会sleep 20s，模拟XMLRPC服务正在长时间处理当前请求。</p><p>再启动fuction_client2.py，由于XMLRPC服务正在处理function_client.py的list_contents()请求，list_contents2()请求会被阻塞住，没响应。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/xmlrpc_demo.png" alt="xmlprc demo"></p><p>这就解释了虚拟机内agent.py提供的XMLRPC服务，为什么会出现无响应的现象，因为有连接建立，有正在处理的请求，<strong>见上面虚拟机内netstat截图中ESTABLISHED状态的连接</strong>。</p><hr><p>（2016.09.22 21:32更新）</p><p>接着回答问题1和2。</p><p>ESTABLISHED，CLOSE_WAIT状态是怎么出现的？先看下TCP协议状态转换图：</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/socket_tcpflow.png" alt="tcpflow"></p><p>TCP连接建立后客户端和服务端进入ESTABLISHED状态，主动关闭连接的一方会进入TIME_WAIT状态，被动关闭连接的一方会进入CLOSE_WAIT状态。</p><p>那么虚拟机内ESTABLISHED，CLOSE_WAIT状态到底是怎么出现的？我又将Bug复现了1遍，仔细观察netstat输出，终于发现了猫腻。下面只抽取了172.16.1.102虚拟机Bug出现时的网络连接状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># netstat -anp | grep :8000</span><br><span class="line">tcp        0      1 172.16.1.1:41240            172.16.1.102:8000           SYN_SENT    3571/python</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># netstat -anp | grep :8000</span><br><span class="line">tcp        0      0 172.16.1.1:41262            172.16.1.102:8000           FIN_WAIT2   -            </span><br><span class="line">tcp        0      0 172.16.1.1:41265            172.16.1.102:8000           ESTABLISHED 3571/python </span><br><span class="line">tcp        0      0 172.16.1.1:41240            172.16.1.102:8000           ESTABLISHED 8805/tcpdump</span><br></pre></td></tr></table></figure><p><strong>注意看这个连接(172.16.1.1:41240 172.16.1.102:8000)，父进程请求完毕后，此连接并没有关闭，因为还被子进程占用着，所以在子进程中仍显示为ESTABLISHED状态。</strong></p><p>写个简单的demo把Bug复现下，更清楚地解释Bug出现的原因。</p><p><a href="https://github.com/consen/demo/blob/master/python/library/socket/echo_server_tcp.py" target="_blank" rel="external">echo_server_tcp.py</a>，接收请求并把请求数据又返回给客户端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a TCP/IP socket</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># Bind the socket to the port</span></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'starting up on %s port %s'</span> % server_address</span><br><span class="line">sock.bind(server_address)</span><br><span class="line"><span class="comment"># Calling listen() puts the socket into server mode, and accept() waits for an</span></span><br><span class="line"><span class="comment"># incoming connection.</span></span><br><span class="line"><span class="comment"># Listen for incoming connections</span></span><br><span class="line">sock.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># Wait for a connection</span></span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'waiting for a connection'</span></span><br><span class="line">    connection, client_address = sock.accept()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'connection from'</span>, client_address</span><br><span class="line">        <span class="comment"># Receive the data in small chunks and retransmit it</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            data = connection.recv(<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'received "%s"'</span> % data</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'sending data back to the client'</span></span><br><span class="line">                connection.sendall(data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'no more data from'</span>, client_address</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Clean up the connection</span></span><br><span class="line">        connection.close()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/consen/demo/blob/master/python/library/socket/echo_client_tcp_child.py" target="_blank" rel="external">echo_client_tcp_child.py</a>，发送请求，并启动了一个子进程cat，子进程会继承父进程的sock。sleep 20s方便观察netstat状态。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a TCP/IP socket</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">cmd = [<span class="string">"cat"</span>]</span><br><span class="line">proc = subprocess.Popen(cmd)</span><br><span class="line"><span class="keyword">print</span> proc.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># For netstat and lsof</span></span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the socket to the port where the server is listening</span></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">print</span> &gt;&gt;sys.stdout, <span class="string">'connecting to %s port %s'</span> % server_address</span><br><span class="line">sock.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Send data</span></span><br><span class="line">    message = <span class="string">'This is the message. It will be repeated.'</span></span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'sending "%s"'</span> % message</span><br><span class="line">    sock.sendall(message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Look for the response</span></span><br><span class="line">    amount_received = <span class="number">0</span></span><br><span class="line">    amount_expected = len(message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> amount_received &lt; amount_expected:</span><br><span class="line">        data = sock.recv(<span class="number">16</span>)</span><br><span class="line">        amount_received += len(data)</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'received "%s"'</span> % data</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'closing socket'</span></span><br><span class="line">    time.sleep(<span class="number">20</span>)  <span class="comment"># For netstat</span></span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/consen/demo/blob/master/python/library/socket/echo_client_tcp.py" target="_blank" rel="external">echo_client_tcp.py</a>，这个和echo_client_tcp_child.py是一样的，只不过取消掉了启动子进程和sleep 20s，立即发送请求。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a TCP/IP socket</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the socket to the port where the server is listening</span></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">print</span> &gt;&gt;sys.stdout, <span class="string">'connecting to %s port %s'</span> % server_address</span><br><span class="line">sock.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Send data</span></span><br><span class="line">    message = <span class="string">'This is the message. It will be repeated.'</span></span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'sending "%s"'</span> % message</span><br><span class="line">    sock.sendall(message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Look for the response</span></span><br><span class="line">    amount_received = <span class="number">0</span></span><br><span class="line">    amount_expected = len(message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> amount_received &lt; amount_expected:</span><br><span class="line">        data = sock.recv(<span class="number">16</span>)</span><br><span class="line">        amount_received += len(data)</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'received "%s"'</span> % data</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'closing socket'</span></span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><ul><li>启动服务：</li></ul><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/server.png" alt="server"></p><p>此时的netstat：</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/server_netstat.png" alt=""></p><ul><li>启动echo_client_tcp_child.py：</li></ul><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/client1.png" alt=""></p><p>此时的netstat:</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/server_netstat.png" alt=""></p><p>观察lsof输出，可以发现子进程已经继承了父进程的sock。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -p 16696</span><br><span class="line">COMMAND   PID      USER   FD   TYPE DEVICE  SIZE/OFF       NODE NAME</span><br><span class="line">cat     16696 xikangjie    3u  sock    0,7       0t0   13005348 can&apos;t identify protocol</span><br></pre></td></tr></table></figure><ul><li>echo_client_tcp_child.py运行结束但还没调用sock.close():</li></ul><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/client1_2.png" alt=""></p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/client1_netstat1.png" alt=""></p><ul><li>echo_client_tcp_child.py调用sock.close()，关闭连接(127.0.0.1:46126 127.0.0.1:10000)，可以看到此连接在子进程中仍显示为ESTABLISHED状态:</li></ul><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/client1_netstat2.png" alt=""></p><ul><li>启动echo_client_tcp.py，可以看到阻塞住，无法发送请求:</li></ul><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/client2.png" alt=""></p><p>此时的netstat:</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/a-network-timeout-bug/client2_netstat.png" alt=""></p><ul><li>将cat进程退出后，可立即发送请求。</li></ul><hr><p>（2016.09.23 10:24更新）</p><p>给Cukoo提交的Pull Request已经merge到master分支：<a href="https://github.com/cuckoosandbox/cuckoo/pull/1100" target="_blank" rel="external">Fix agent.py timeout error caused by tcpdump process.</a></p><hr><p>总结：</p><p>理解此Bug需要搞明白子进程继承了父进程的文件描述符（网络连接也是文件描述符的一种）会有什么影响。简单讲就是子进程继承了父进程的网络连接，父进程关闭网络连接后，由于此连接也被子进程占用，所以没有真正关闭，导致服务器无法响应新的请求。</p><ol><li>解决Bug的第一步是把Bug复现，用最简单的方法把Bug复现，就相当于把Bug解决了一半。</li><li>多积累技术基础，才能透过现象看到本质。</li></ol><p>参考：</p><ul><li><a href="https://typecodes.com/cseries/tcpdumpwiresharkclosewait1.html" target="_blank" rel="external">使用TCPDUMP和Wireshark排查服务端CLOSE_WAIT（一）</a></li><li><a href="https://typecodes.com/cseries/tcpdumpwiresharkclosewait2.html" target="_blank" rel="external">使用TCPDUMP和Wireshark排查服务端CLOSE_WAIT（二）</a></li><li><a href="http://mail-archives.apache.org/mod_mbox/ws-xmlrpc-user/200411.mbox/%3CFEFA185A-395A-11D9-BBB9-000A95B9441C@wilson.co.uk%3E" target="_blank" rel="external">ws-xmlrpc-user mailing list archives</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在cuckoo上测试我的xenforce，任务运行结果出现大量timeout错误，虽然以前也遇到过这个问题，但没当回事放过去了，现在有了xenforce还出现这种问题，是可忍孰不可忍，今天就认真排查下这个问题，消灭这只bug。&lt;/p&gt;
&lt;p&gt;Bug现象是这样的，任务运行超时，错误日志有两种：&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://consen.github.io/categories/Network/"/>
    
    
      <category term="Process" scheme="https://consen.github.io/tags/Process/"/>
    
  </entry>
  
  <entry>
    <title>Anti-VM之RDTSC指令</title>
    <link href="https://consen.github.io/2016/09/12/Anti-VM-via-RDTSC/"/>
    <id>https://consen.github.io/2016/09/12/Anti-VM-via-RDTSC/</id>
    <published>2016-09-12T12:08:17.000Z</published>
    <updated>2017-11-15T13:13:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>上篇<a href="https://consen.github.io/2016/09/11/Anti-VM-via-CPUID/">《Anti-VM之CPUID指令》</a>，通过CPUID指令获取CPU信息，来判断环境是否是虚拟的。这篇从时间角度判断环境是否是虚拟的。</p><p>Intel和AMD为处理器增加了虚拟化扩展（Intel <strong>VT-x</strong>, AMD <strong>AMD-V</strong>），使得操作系统不做修改就可虚拟化。以Intel VT-x为例，VMM（Virtual Machine Monitor）运行在root模式，虚拟机运行在非root模式，在非root模式下，一些指令如RDMSR，WRMSR，CPUID需要在VMM才能执行，即会触发 <strong>VM exit</strong>, 从而带来时间上的开销，通过统计时间，就可以判断当前环境是否是虚拟的。</p><a id="more"></a><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/blackhole.png" alt="blackhole"></p><blockquote><p>The Time Stamp Counter (TSC) is a 64-bit register present on all x86 processors since the Pentium. It counts the number of cycles since reset. The instruction RDTSC returns the TSC in EDX:EAX. In x86-64 mode, RDTSC also clears the higher 32 bits of RAX and RDX. Its opcode is 0F 31.</p></blockquote><p>TSC是一个64位寄存器，统计CPU时钟周期，可以用来高精度统计时间。RDTSC指令读取TSC值。</p><p>RDTSC和CPUID都是非特权（unprivileged）指令，可以在用户态调用。</p><p>检测代码 <a href="https://github.com/consen/demo/blob/master/c/syntax/asm/rdtsc.c" target="_blank" rel="external">rdtsc.c</a> ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">rdtsc_diff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ret, ret2;</span><br><span class="line">    <span class="keyword">unsigned</span> eax, edx;</span><br><span class="line">    __asm__ volatile("rdtsc" : "=a" (eax), "=d" (edx));</span><br><span class="line">    ret  = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)eax) | (((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)edx) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    __asm__ volatile("rdtsc" : "=a" (eax), "=d" (edx));</span><br><span class="line">    ret2  = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)eax) | (((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)edx) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%llu - %llu) "</span>, ret, ret2);</span><br><span class="line">    <span class="keyword">return</span> ret2 - ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">rdtsc_diff_vmexit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ret, ret2;</span><br><span class="line">    <span class="keyword">unsigned</span> eax, edx;</span><br><span class="line">    __asm__ volatile("rdtsc" : "=a" (eax), "=d" (edx));</span><br><span class="line">    ret  = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)eax) | (((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)edx) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="comment">/* vm exit forced here. it uses: eax = 0; cpuid; */</span></span><br><span class="line">    __asm__ volatile("cpuid" : /* no output */ : "a"(0x00));</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    __asm__ volatile("rdtsc" : "=a" (eax), "=d" (edx));</span><br><span class="line">    ret2  = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)eax) | (((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)edx) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%llu - %llu) "</span>, ret, ret2);</span><br><span class="line">    <span class="keyword">return</span> ret2 - ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpu_rdtsc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> avg = <span class="number">0</span>, sub;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sub = rdtsc_diff();</span><br><span class="line">        avg = avg + sub;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rdtsc difference: %d\n"</span>, sub);</span><br><span class="line">        usleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    avg = avg / <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"difference average is: %d\n"</span>, avg);</span><br><span class="line">    <span class="keyword">return</span> (avg &lt; <span class="number">1000</span> &amp;&amp; avg &gt; <span class="number">0</span>) ? FALSE : TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpu_rdtsc_force_vmexit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> avg = <span class="number">0</span>, sub;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sub = rdtsc_diff_vmexit();</span><br><span class="line">        avg = avg + sub;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rdtsc_force_vmexit difference: %d\n"</span>, sub);</span><br><span class="line">        usleep(<span class="number">500</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    avg = avg / <span class="number">10</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"difference average is: %d\n"</span>, avg);</span><br><span class="line">    <span class="keyword">return</span> (avg &lt; <span class="number">1000</span> &amp;&amp; avg &gt; <span class="number">0</span>) ? FALSE : TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cpu_rdtsc: %d\n"</span>, cpu_rdtsc());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cpu_rdtsc_force_vmexit: %d\n"</span>, cpu_rdtsc_force_vmexit());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在物理机上运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2724639288020470 - 2724639288020494) rdtsc difference: 24</span><br><span class="line">(2724639289813128 - 2724639289813156) rdtsc difference: 28</span><br><span class="line">(2724639291344684 - 2724639291344708) rdtsc difference: 24</span><br><span class="line">(2724639292869608 - 2724639292869668) rdtsc difference: 60</span><br><span class="line">(2724639294412600 - 2724639294412628) rdtsc difference: 28</span><br><span class="line">(2724639295888716 - 2724639295888744) rdtsc difference: 28</span><br><span class="line">(2724639297385732 - 2724639297385760) rdtsc difference: 28</span><br><span class="line">(2724639298878740 - 2724639298878768) rdtsc difference: 28</span><br><span class="line">(2724639300371292 - 2724639300371320) rdtsc difference: 28</span><br><span class="line">(2724639301864924 - 2724639301864952) rdtsc difference: 28</span><br><span class="line">difference average is: 30</span><br><span class="line">cpu_rdtsc: 0</span><br><span class="line">(2724639303466468 - 2724639303466608) rdtsc_force_vmexit difference: 140</span><br><span class="line">(2724639304950316 - 2724639304950440) rdtsc_force_vmexit difference: 124</span><br><span class="line">(2724639306452456 - 2724639306452576) rdtsc_force_vmexit difference: 120</span><br><span class="line">(2724639307949500 - 2724639307949624) rdtsc_force_vmexit difference: 124</span><br><span class="line">(2724639309446084 - 2724639309446208) rdtsc_force_vmexit difference: 124</span><br><span class="line">(2724639310963224 - 2724639310963344) rdtsc_force_vmexit difference: 120</span><br><span class="line">(2724639312455892 - 2724639312456012) rdtsc_force_vmexit difference: 120</span><br><span class="line">(2724639313952608 - 2724639313952728) rdtsc_force_vmexit difference: 120</span><br><span class="line">(2724639315444756 - 2724639315444880) rdtsc_force_vmexit difference: 124</span><br><span class="line">(2724639316941332 - 2724639316941452) rdtsc_force_vmexit difference: 120</span><br><span class="line">difference average is: 123</span><br><span class="line">cpu_rdtsc_force_vmexit: 0</span><br></pre></td></tr></table></figure><p>在VMware虚拟机上运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2201234633835839 - 2201234633835857) rdtsc difference: 18</span><br><span class="line">(2201234638344307 - 2201234638344325) rdtsc difference: 18</span><br><span class="line">(2201234641440343 - 2201234641440361) rdtsc difference: 18</span><br><span class="line">(2201234645264790 - 2201234645264814) rdtsc difference: 24</span><br><span class="line">(2201234648970696 - 2201234648970714) rdtsc difference: 18</span><br><span class="line">(2201234652584847 - 2201234652584865) rdtsc difference: 18</span><br><span class="line">(2201234655954692 - 2201234655954710) rdtsc difference: 18</span><br><span class="line">(2201234660290766 - 2201234660290790) rdtsc difference: 24</span><br><span class="line">(2201234662928102 - 2201234662928126) rdtsc difference: 24</span><br><span class="line">(2201234666890620 - 2201234666890638) rdtsc difference: 18</span><br><span class="line">difference average is: 19</span><br><span class="line">cpu_rdtsc: 0</span><br><span class="line">(2201234670145762 - 2201234670148696) rdtsc_force_vmexit difference: 2934</span><br><span class="line">(2201234674344607 - 2201234674347196) rdtsc_force_vmexit difference: 2589</span><br><span class="line">(2201234677321168 - 2201234677322647) rdtsc_force_vmexit difference: 1479</span><br><span class="line">(2201234681439262 - 2201234681441659) rdtsc_force_vmexit difference: 2397</span><br><span class="line">(2201234684594947 - 2201234684596750) rdtsc_force_vmexit difference: 1803</span><br><span class="line">(2201234689163149 - 2201234689165630) rdtsc_force_vmexit difference: 2481</span><br><span class="line">(2201234693566946 - 2201234693568884) rdtsc_force_vmexit difference: 1938</span><br><span class="line">(2201234699323186 - 2201234699325493) rdtsc_force_vmexit difference: 2307</span><br><span class="line">(2201234702590461 - 2201234702592354) rdtsc_force_vmexit difference: 1893</span><br><span class="line">(2201234706444177 - 2201234706446514) rdtsc_force_vmexit difference: 2337</span><br><span class="line">difference average is: 2215</span><br><span class="line">cpu_rdtsc_force_vmexit: 1</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter" target="_blank" rel="external">Wikipedia Time Stamp Counter</a></li><li><a href="http://blog.badtrace.com/tag/antivm/" target="_blank" rel="external">rdtsc x86 instruction to detect virtual machines</a></li><li><a href="https://people.eecs.berkeley.edu/~cthompson/papers/virt-detect.pdf" target="_blank" rel="external">Virtualization Detection: New Strategies and Their Effectiveness</a></li><li><a href="https://xenbits.xen.org/docs/unstable/misc/tscmode.txt" target="_blank" rel="external">Xen TSC Mode HOWTO</a></li><li><a href="http://xenbits.xen.org/docs/unstable/features/feature-levelling.html" target="_blank" rel="external">Xen Feature Levelling</a></li><li><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="external">GCC-Inline-Assembly-HOWTO</a></li><li><a href="https://github.com/a0rtega/pafish" target="_blank" rel="external">Pafish</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇&lt;a href=&quot;https://consen.github.io/2016/09/11/Anti-VM-via-CPUID/&quot;&gt;《Anti-VM之CPUID指令》&lt;/a&gt;，通过CPUID指令获取CPU信息，来判断环境是否是虚拟的。这篇从时间角度判断环境是否是虚拟的。&lt;/p&gt;
&lt;p&gt;Intel和AMD为处理器增加了虚拟化扩展（Intel &lt;strong&gt;VT-x&lt;/strong&gt;, AMD &lt;strong&gt;AMD-V&lt;/strong&gt;），使得操作系统不做修改就可虚拟化。以Intel VT-x为例，VMM（Virtual Machine Monitor）运行在root模式，虚拟机运行在非root模式，在非root模式下，一些指令如RDMSR，WRMSR，CPUID需要在VMM才能执行，即会触发 &lt;strong&gt;VM exit&lt;/strong&gt;, 从而带来时间上的开销，通过统计时间，就可以判断当前环境是否是虚拟的。&lt;/p&gt;
    
    </summary>
    
      <category term="Security" scheme="https://consen.github.io/categories/Security/"/>
    
    
      <category term="Anti-VM" scheme="https://consen.github.io/tags/Anti-VM/"/>
    
      <category term="RDTSC" scheme="https://consen.github.io/tags/RDTSC/"/>
    
  </entry>
  
  <entry>
    <title>Anti-VM之CPUID指令</title>
    <link href="https://consen.github.io/2016/09/11/Anti-VM-via-CPUID/"/>
    <id>https://consen.github.io/2016/09/11/Anti-VM-via-CPUID/</id>
    <published>2016-09-11T21:10:03.000Z</published>
    <updated>2017-11-15T13:13:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>相对于传统的静态分析检测，<strong>动态分析</strong>技术可以获得恶意样本的详细行为信息。恶意样本作者为了规避动态检测，采取了各种手段，如Anti-VM, Anti-Sandbox, Anti-Debugging。</p><p><strong>Anti-VM</strong>是为了检测当前运行环境是否是虚拟环境，如果是，恶意样本会停止恶意行为，让安全研究员误认为此样本是良性的。比如恶意样本如果在物理环境下运行，会去连接C&amp;C服务器，当检测到是在虚拟环境下运行时，则去连接正常的域名。</p><a id="more"></a><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/MatrixBluePillRedPill2.jpg" alt="redpillbluepill"></p><p>动态检测不管借助哪种虚拟化工具，如VMware、VirtualBox、Xen、KVM等，都会留下蛛丝马迹，表征当前环境是虚拟的。</p><p>接下来就借助<code>CPUID</code>指令，检测当前环境是否是虚拟的。</p><p><code>CPUID</code>指令用来获取CPU信息，将功能号作为参数传入<code>EAX</code>寄存器，CPUID将信息返回到<code>EAX、EBX、ECX、EDX</code>寄存器。下面是两个检测虚拟环境的功能号：</p><ul><li>EAX = 1，获取CPU功能信息，如果ECX第31位为1， 则表明有hypervisor存在，即环境是虚拟的。</li><li>EAX = 0x40000000, 获取hypervisor信息，返回12字节长度字符串：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;KVMKVMKVM\0\0\0&quot;    KVM</span><br><span class="line">&quot;Microsoft Hv&quot;       Microsoft Hyper-V or Windows Virtual PC</span><br><span class="line">&quot;VMwareVMware&quot;       VMware</span><br><span class="line">&quot;XenVMMXenVMM&quot;       Xen</span><br><span class="line">&quot;prl hyperv  &quot;       Parallels</span><br><span class="line">&quot;VBoxVBoxVBox&quot;       VirtualBox</span><br></pre></td></tr></table></figure><p>检测代码 <a href="https://github.com/consen/demo/blob/master/c/syntax/asm/cpuid2.c" target="_blank" rel="external">cpuid.c</a> ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cpuid_hv_bit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ecx;</span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span><span class="params">(<span class="string">"cpuid"</span> \</span></span></span><br><span class="line">            : "=c"(ecx) \</span><br><span class="line">            : <span class="string">"a"</span>(<span class="number">0x01</span>));</span><br><span class="line">    <span class="keyword">return</span> (ecx &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpuid_hv_vendor_00</span><span class="params">(<span class="keyword">char</span> * vendor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ebx = <span class="number">0</span>, ecx = <span class="number">0</span>, edx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span><span class="params">(<span class="string">"cpuid"</span> \</span></span></span><br><span class="line">            : "=b"(ebx), \</span><br><span class="line">            <span class="string">"=c"</span>(ecx), \</span><br><span class="line">            <span class="string">"=d"</span>(edx) \</span><br><span class="line">            : <span class="string">"a"</span>(<span class="number">0x40000000</span>));</span><br><span class="line">    <span class="built_in">sprintf</span>(vendor  , <span class="string">"%c%c%c%c"</span>, ebx, (ebx &gt;&gt; <span class="number">8</span>), (ebx &gt;&gt; <span class="number">16</span>), (ebx &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    <span class="built_in">sprintf</span>(vendor+<span class="number">4</span>, <span class="string">"%c%c%c%c"</span>, ecx, (ecx &gt;&gt; <span class="number">8</span>), (ecx &gt;&gt; <span class="number">16</span>), (ecx &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    <span class="built_in">sprintf</span>(vendor+<span class="number">8</span>, <span class="string">"%c%c%c%c"</span>, edx, (edx &gt;&gt; <span class="number">8</span>), (edx &gt;&gt; <span class="number">16</span>), (edx &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    vendor[<span class="number">12</span>] = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpu_hv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cpuid_hv_bit() ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_write_hv_vendor</span><span class="params">(<span class="keyword">char</span> * vendor)</span> </span>&#123;</span><br><span class="line">    cpuid_hv_vendor_00(vendor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpu_known_vm_vendors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> count = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> cpu_hv_vendor[<span class="number">13</span>];</span><br><span class="line">    <span class="built_in">string</span> strs[count];</span><br><span class="line">    strs[<span class="number">0</span>] = <span class="string">"KVMKVMKVM\0\0\0"</span>; <span class="comment">/* KVM */</span></span><br><span class="line">    strs[<span class="number">1</span>] = <span class="string">"Microsoft Hv"</span>; <span class="comment">/* Microsoft Hyper-V or Windows Virtual PC */</span></span><br><span class="line">    strs[<span class="number">2</span>] = <span class="string">"VMwareVMware"</span>; <span class="comment">/* VMware */</span></span><br><span class="line">    strs[<span class="number">3</span>] = <span class="string">"XenVMMXenVMM"</span>; <span class="comment">/* Xen */</span></span><br><span class="line">    strs[<span class="number">4</span>] = <span class="string">"prl hyperv  "</span>; <span class="comment">/* Parallels */</span></span><br><span class="line">    strs[<span class="number">5</span>] = <span class="string">"VBoxVBoxVBox"</span>; <span class="comment">/* VirtualBox */</span></span><br><span class="line">    cpu_write_hv_vendor(cpu_hv_vendor);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(cpu_hv_vendor, strs[i], <span class="number">12</span>)) <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cpu_hv_vendor[<span class="number">13</span>];</span><br><span class="line">    cpu_write_hv_vendor(cpu_hv_vendor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CPU Hypervisor Bit: %d\n"</span>, cpu_hv());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hypervisor: %s, is known vm vendor: %s\n"</span>, cpu_hv_vendor, cpu_known_vm_vendors() ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在物理机下运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU Hypervisor Bit: 0</span><br><span class="line">Hypervisor: , is known vm vendor: false</span><br></pre></td></tr></table></figure><p>在VMware虚拟机下运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU Hypervisor Bit: 1</span><br><span class="line">Hypervisor: VMwareVMware, is known vm vendor: true</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://en.wikipedia.org/wiki/CPUID" target="_blank" rel="external">Wikipedia CPUID</a></li><li><a href="http://www.sandpile.org/x86/cpuid.htm" target="_blank" rel="external">x86 architecture CPUID</a></li><li><a href="http://xenbits.xen.org/docs/unstable/features/feature-levelling.html" target="_blank" rel="external">Xen Feature Levelling</a></li><li><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="external">GCC-Inline-Assembly-HOWTO</a></li><li><a href="https://github.com/a0rtega/pafish" target="_blank" rel="external">Pafish</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对于传统的静态分析检测，&lt;strong&gt;动态分析&lt;/strong&gt;技术可以获得恶意样本的详细行为信息。恶意样本作者为了规避动态检测，采取了各种手段，如Anti-VM, Anti-Sandbox, Anti-Debugging。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anti-VM&lt;/strong&gt;是为了检测当前运行环境是否是虚拟环境，如果是，恶意样本会停止恶意行为，让安全研究员误认为此样本是良性的。比如恶意样本如果在物理环境下运行，会去连接C&amp;amp;C服务器，当检测到是在虚拟环境下运行时，则去连接正常的域名。&lt;/p&gt;
    
    </summary>
    
      <category term="Security" scheme="https://consen.github.io/categories/Security/"/>
    
    
      <category term="Anti-VM" scheme="https://consen.github.io/tags/Anti-VM/"/>
    
      <category term="CPUID" scheme="https://consen.github.io/tags/CPUID/"/>
    
  </entry>
  
  <entry>
    <title>GnuPG实战</title>
    <link href="https://consen.github.io/2016/08/18/GnuPG-practice/"/>
    <id>https://consen.github.io/2016/08/18/GnuPG-practice/</id>
    <published>2016-08-18T21:49:24.000Z</published>
    <updated>2017-11-15T13:13:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>这两天有一个大新闻，和美国国家安全局（NSA）有密切关系的方程式组织（<code>Equation Group</code>）遭到<code>The Shadow Brokers</code>攻击，大量黑客工具被泄露到网上，如果你感兴趣，一定已经下载下来把玩了一番:)。</p><p>将文件解压缩后，会看到文件用了<a href="https://www.gnupg.org/" target="_blank" rel="external">GnuPG</a>工具进行加密，简单了解了下GnuPG怎么用，现在分享出来。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip EQGRP-Auction-Files.zip -d EQGRP-Auction-Files</span><br><span class="line">$ ls EQGRP-Auction-Files</span><br><span class="line">eqgrp-auction-file.tar.xz.gpg</span><br><span class="line">eqgrp-auction-file.tar.xz.gpg.sig</span><br><span class="line">eqgrp-free-file.tar.xz.gpg</span><br><span class="line">eqgrp-free-file.tar.xz.gpg.sig</span><br><span class="line">public.key.asc</span><br><span class="line">sha256sum.txt</span><br><span class="line">sha256sum.txt.sig</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CentOS安装GnuPG：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install gnupg2</span><br></pre></td></tr></table></figure><h2 id="对称加密-解密"><a href="#对称加密-解密" class="headerlink" title="对称加密/解密"></a>对称加密/解密</h2><p>加密解密使用相同的密钥。</p><h3 id="加密："><a href="#加密：" class="headerlink" title="加密："></a>加密：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg -c --cipher-algo AES256 demo.txt</span><br></pre></td></tr></table></figure><p>按提示输入密码，生成<code>demo.txt.gpg</code>加密文件。</p><h3 id="解密："><a href="#解密：" class="headerlink" title="解密："></a>解密：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg demo.txt.gpg</span><br></pre></td></tr></table></figure><p>按提示输入密码，生成<code>demo.txt</code>解密文件。</p><h3 id="解密Equation-Group"><a href="#解密Equation-Group" class="headerlink" title="解密Equation Group:"></a>解密Equation Group:</h3><p><code>The Shadow Brokers</code>释放了文件<code>eqgrp-free-file.tar.xz.gpg</code>的密码<code>theequationgroup</code>，可以直接解密；文件<code>eqgrp-auction-file.tar.xz.gpg</code>出价5亿美刀拍卖，只能坐等后面好戏了:)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg eqgrp-free-file.tar.xz.gpg</span><br></pre></td></tr></table></figure><p>按提示输入密码：</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/gpg-introduction/decrypt.png" alt="decrypt"></p><p>得到文件<code>eqgrp-free-file.tar.xz</code>，直接解压缩：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -xvf eqgrp-free-file.tar.xz</span><br></pre></td></tr></table></figure><p>得到Fireware文件夹，所有秘密尽收眼底：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree Firewall/ -L 1 -F</span><br><span class="line">Firewall/</span><br><span class="line">├── BANANAGLEE/</span><br><span class="line">├── BARGLEE/</span><br><span class="line">├── BLATSTING/</span><br><span class="line">├── BUZZDIRECTION/</span><br><span class="line">├── EXPLOITS/</span><br><span class="line">├── OPS/</span><br><span class="line">├── padding</span><br><span class="line">├── SCRIPTS/</span><br><span class="line">├── TOOLS/</span><br><span class="line">└── TURBO/</span><br></pre></td></tr></table></figure><h2 id="非对称加密-解密"><a href="#非对称加密-解密" class="headerlink" title="非对称加密/解密"></a>非对称加密/解密</h2><p>公钥加密，私钥解密。</p><h3 id="生成密钥对："><a href="#生成密钥对：" class="headerlink" title="生成密钥对："></a>生成密钥对：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --gen-key</span><br></pre></td></tr></table></figure><p>列出公钥:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --list-keys</span><br></pre></td></tr></table></figure><p>列出私钥:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --list-secret-keys</span><br></pre></td></tr></table></figure><p>导出公钥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg -a -o public-key.txt --export key-identifier</span><br></pre></td></tr></table></figure><p>这个公钥文件<code>pulibc-key.txt</code>就可以拿给别人用了。</p><h3 id="加密：-1"><a href="#加密：-1" class="headerlink" title="加密："></a>加密：</h3><p>如果需要使用的公钥不存在，需要提前导入。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --encrypt --recipient key-identifier demo.txt</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">gpg -e -r key-identifier demo.txt</span><br></pre></td></tr></table></figure><p>生成加密文件demo.txt.gpg。</p><h3 id="解密：-1"><a href="#解密：-1" class="headerlink" title="解密："></a>解密：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --output demo.txt --decrypt demo.txt.gpg</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">gpg demo.txt.gpg</span><br></pre></td></tr></table></figure><p>生成解密文件demo.txt。</p><h2 id="签名-验签"><a href="#签名-验签" class="headerlink" title="签名/验签"></a>签名/验签</h2><blockquote><p>非对称加密的另一个用途是用于数字签名，签署者使用他的私钥（应用一个签名算法）来签署文档。验证者使用签署者的公钥（公开的）验证文档。当一个文档被签署时，任何人都能验证它，因为任何人都能访问签署者的公钥。由于私钥的保密性，签名是无法伪造的。</p></blockquote><h3 id="签名："><a href="#签名：" class="headerlink" title="签名："></a>签名：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --armor -output demo.txt.sig --detach-sign demo.txt</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">$ gpg -a -o demo.txt.sig -b demo.txt</span><br></pre></td></tr></table></figure><p>按提示输入私钥密码，输出<code>demo.txt.sig</code>签名文件。</p><h3 id="验签："><a href="#验签：" class="headerlink" title="验签："></a>验签：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --verify demo.txt.sig demo.txt</span><br><span class="line">gpg: Signature made Thu 18 Aug 2016 05:08:22 PM CST using RSA key ID 26940C51</span><br><span class="line">gpg: Good signature from &quot;xikangjie (test) &lt;xikangjie@consen.cn&gt;&quot;</span><br></pre></td></tr></table></figure><p>如果demo.txt文件存在，可以省略.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --verify demo.txt.sig</span><br></pre></td></tr></table></figure><h3 id="Equation-Group验签："><a href="#Equation-Group验签：" class="headerlink" title="Equation Group验签："></a>Equation Group验签：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --verify sha256sum.txt.sig </span><br><span class="line">gpg: Signature made Mon 01 Aug 2016 11:23:02 AM CST using RSA key ID CB5C0C1B</span><br><span class="line">gpg: Can&apos;t check signature: No public key</span><br></pre></td></tr></table></figure><p>提示没有公钥，这就是文件<code>public.key.asc</code>的作用，将其导入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --import public.key.asc </span><br><span class="line">gpg: key CB5C0C1B: public key &quot;The Shadow Broker &lt;theshadowbroker@mail.i2p&gt;&quot; imported</span><br><span class="line">gpg: Total number processed: 1</span><br><span class="line">gpg:               imported: 1  (RSA: 1)</span><br></pre></td></tr></table></figure><p>再次验签：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --verify sha256sum.txt.sig</span><br><span class="line">gpg: Signature made Mon 01 Aug 2016 11:23:02 AM CST using RSA key ID CB5C0C1B</span><br><span class="line">gpg: Good signature from &quot;The Shadow Broker &lt;theshadowbroker@mail.i2p&gt;&quot;</span><br><span class="line">gpg: WARNING: This key is not certified with a trusted signature!</span><br><span class="line">gpg:          There is no indication that the signature belongs to the owner.</span><br><span class="line">Primary key fingerprint: 8369 E676 9C13 F624 3103  15E6 0412 4F2C CB5C 0C1B</span><br></pre></td></tr></table></figure><p>警告公钥不受信任，将其签入设为信任：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --sign-key &apos;The Shadow Broker&apos;</span><br></pre></td></tr></table></figure><p>再次验签：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpg --verify sha256sum.txt.sig </span><br><span class="line">gpg: Signature made Mon 01 Aug 2016 11:23:02 AM CST using RSA key ID CB5C0C1B</span><br><span class="line">gpg: Good signature from &quot;The Shadow Broker &lt;theshadowbroker@mail.i2p&gt;&quot;</span><br></pre></td></tr></table></figure><p><strong>参考文档：</strong></p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="external">GPG入门教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">RSA算法原理（一）</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="external">RSA算法原理（二）</a></li><li><a href="https://archboy.org/2013/05/15/gnupg-pgp-encrypt-decrypt-file-and-digital-signing-easy-tutorial/" target="_blank" rel="external">使用 GnuPG 实现文件加密和数字签名</a></li><li><a href="http://www.tutonics.com/2012/11/gpg-encryption-guide-part-1.html" target="_blank" rel="external">GPG Encryption Guide</a></li><li><a href="http://thehackernews.com/2016/08/nsa-hacking-tools.html" target="_blank" rel="external">NSA’s Hacking Group Hacked! Bunch of Private Hacking Tools Leaked Online</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天有一个大新闻，和美国国家安全局（NSA）有密切关系的方程式组织（&lt;code&gt;Equation Group&lt;/code&gt;）遭到&lt;code&gt;The Shadow Brokers&lt;/code&gt;攻击，大量黑客工具被泄露到网上，如果你感兴趣，一定已经下载下来把玩了一番:)。&lt;/p&gt;
&lt;p&gt;将文件解压缩后，会看到文件用了&lt;a href=&quot;https://www.gnupg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GnuPG&lt;/a&gt;工具进行加密，简单了解了下GnuPG怎么用，现在分享出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Security" scheme="https://consen.github.io/categories/Security/"/>
    
    
      <category term="GnuPG" scheme="https://consen.github.io/tags/GnuPG/"/>
    
  </entry>
  
  <entry>
    <title>Switch Browser From Mathon to Chrome</title>
    <link href="https://consen.github.io/2016/07/19/switch-browser-from-mathon-to-chrome/"/>
    <id>https://consen.github.io/2016/07/19/switch-browser-from-mathon-to-chrome/</id>
    <published>2016-07-19T13:29:57.000Z</published>
    <updated>2017-11-15T13:13:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现一个有意思的小工具，遗憾的是只通过Chrome扩展形式提供，这直接诱发我将默认浏览器从遨游Mathon切换到谷歌Chrome。</p><p>Mathon由于提供了很多非常人性化的功能，深得用户喜欢，赢得了一大批粉丝，官方数据是全球有4亿用户，我就是其中之一，使用遨游三年有余。</p><a id="more"></a><p>下面这些微创新是我一直不想放弃Mathon的原因：</p><ol><li><strong>界面</strong>，简洁的UI，尤其是黑色边框主题，很符合我的口味。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/mathon_ui.png" alt=""></li><li><strong>拖拽打开</strong>，网页上链接，鼠标左键点住轻轻拖拽一下，自动在后台打开，你可继续在当前标签页浏览。</li><li><strong>会话管理</strong>，如果浏览器不小心被关闭，再次打开时可以恢复上次的会话，继续浏览之前的网页。</li><li><strong>资源嗅探</strong>，自动嗅探当前网页的视频和图片，方便批量下载。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/mathon_resource_sniffer.png" alt=""></li><li><strong>繁转简</strong>，如果浏览的网页字体是繁体，可以一键将其转为简体中文。</li><li><strong>代理</strong>，代理设置集成到浏览器中，轻轻松松设置代理，科学上网。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/mathon_proxy.png" alt=""></li><li><strong>广告过滤</strong>，AdBlock Plus也被集成到了浏览器中，自动屏蔽广告，上网更干净清爽。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/mathon_adblock.png" alt=""></li><li><strong>数据同步</strong>，将书签等配置同步到遨游账户，这样在不同设备上获得一致的使用体验。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/mathon_sync.png" alt=""></li></ol><p>还有很多功能，就不罗列了，上面几条是对我触动比较深的。</p><p>但是这些人性化的功能在Chrome下已经实现了，即使没有，也很容易找到对应的扩展：</p><ol><li>在Chrome网上应用店中的主题背景一栏中，有各种主题供你选择，但Chrome默认UI已经简洁到完美，所以使用默认就好，不再折腾了。</li><li>在Chrome下按住Ctrl并鼠标左键单击链接，链接就自动在后台打开；或者也可以鼠标右键单击链接，选择“在新标签页中打开链接”。</li><li>会话管理，在Chrome下，我使用了OneTab扩展，非常棒。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/chrome_onetab.png" alt=""></li><li>资源嗅探，用了下扩展“Chrono下载管理器”，无感，卸载了，似乎资源嗅探并非必需。</li><li>繁转简，“新同文堂”扩展不错。</li><li>代理，装了个SwitchyOmega扩展，非常好用，甚至胜过Mathon自带的代理。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/chrome_proxy.png" alt=""></li><li>广告过滤，直接装个AdBlock Plus扩展，Chrome必备扩展，不说了。</li><li>Chrome也有账户同步功能，而且更高级。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/chrome_sync.png" alt=""></li></ol><p>除了这些，还有什么，使Chrome成为全球市场占有率第一的浏览器呢？</p><ol><li><strong>跨平台</strong>，不单是指在不同的Windows设备上有一致的使用体验，在Linux、macOS，甚至iOS、Android平台下，无缝切换。马上要入手MacBook Pro，所以Chrome完美跨平台支持也是我选择Chrome的原因之一。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/chrome-new.jpg" alt=""></li><li><strong>扩展，生态</strong>，Chrome有自己的网上应用店<a href="https://chrome.google.com/webstore/category/apps" target="_blank" rel="external">Chrome Web Store</a>, 上面有丰富的应用、游戏、扩展、主题，给了用户最大的自由去扩展、自定义Chrome。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/webstore-consumer.jpg" alt=""></li><li><strong>安全</strong>，安全浏览技术、沙盒、定期的自动升级更新，还有<a href="https://www.google.ie/about/appsecurity/chrome-rewards/" target="_blank" rel="external">Chrome Reward Program</a>，鼓励安全研究员报告Chrome漏洞，并获得现金奖励，这些都使Chrome的安全性得到极大保证。</li><li><strong>科技感</strong>， Chrome是开源的，在<a href="http://www.chromium.org/" target="_blank" rel="external">Chromium</a>可以查看源码；Chrome内核从刚开始的chromium到现在的Blink，都被国产浏览器拥入怀抱，加上IE内核，美其名曰“双核浏览器”；Javascript引擎V8由于强悍的性能也被得到广泛应用，比如Node.js。</li><li><strong>简洁干净极速</strong>，用了就感受到了，快得没得说。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/chrome_ui.png" alt=""></li><li><strong>标准支持</strong>，对WebGL的支持，可以让你在浏览器中体验3D效果； 还有对W3C浏览器相关API的实现，Chrome排在第一位。所以有些网页在Chrome下就能正常打开，看到炫酷的效果，在其他浏览器下则是一堆乱码。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/w3c_api.png" alt=""></li><li><strong>Google服务集成</strong>，Chrome集成了很多Google自家服务应用，如果你是Google铁杆粉，早就用上Chrome了:)。<br><img src="http://7xtc3e.com1.z0.glb.clouddn.com/switch-browser-from-mathon-to-chrome/chrome_google_app.png" alt=""></li></ol><p>当然，还有很多很多功能，等着我去发掘探索，比如在Chrome浏览器地址栏输入chrome://chrome-urls/，会显示一份Chrome URLs列表。</p><p><strong>似乎，随着阅历的增加，越往后，越关注内在与本质，对一些微创新、浮于表面的东西，慢慢无感了。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现一个有意思的小工具，遗憾的是只通过Chrome扩展形式提供，这直接诱发我将默认浏览器从遨游Mathon切换到谷歌Chrome。&lt;/p&gt;
&lt;p&gt;Mathon由于提供了很多非常人性化的功能，深得用户喜欢，赢得了一大批粉丝，官方数据是全球有4亿用户，我就是其中之一，使用遨游三年有余。&lt;/p&gt;
    
    </summary>
    
      <category term="Toolbox" scheme="https://consen.github.io/categories/Toolbox/"/>
    
    
      <category term="Chrome" scheme="https://consen.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>《Flask Web Development》Book Review</title>
    <link href="https://consen.github.io/2016/07/14/Flask-Web-Development-book-review/"/>
    <id>https://consen.github.io/2016/07/14/Flask-Web-Development-book-review/</id>
    <published>2016-07-14T10:23:30.000Z</published>
    <updated>2017-11-15T15:52:16.884Z</updated>
    
    <content type="html"><![CDATA[<p>这本书是偶然在一篇博客<a href="http://python.jobbole.com/85620/" target="_blank" rel="external">《如果有人让你推荐Python技术书，请让他看这个列表》</a>中看到的，《Flask Web Development》被列在进阶级，豆瓣评分8.6，算是比较高，比较受公众认可的了。正好最近工作中要用到Web开发相关知识，花了两天时间看了下这本书，果然没让人失望。</p><p>这是一本写作技巧和Web技术并重的书，从第一页开始就让你爱不释手，想一口气读完，酣畅淋漓。</p><a id="more"></a><p>作者循循善诱，先抛出一个问题，然后给出一种解决方案，有时候这种解决方案是最佳的，有时候并不完美，有副作用，这也是作者刻意安排的，因为作者又要抛出另外一个问题，引出另外一个有意思的话题。时不时一语道破天机，让你自然而然地接受知识。读书的过程中你就会感受到，隐隐有一根主线，把所有零碎的知识都串联起来。把复杂抽象的知识通过简单具体的方式呈现，娓娓道来。</p><p>作者对书中内容字斟句酌，精心布局，如果没有长年累月的积累，没有深入的实践与思考，是达不到这样的高度的。</p><p>也许《Flask Web Development》这本书中讲的Flask Web开发，你以后不一定会用到，但书中内容的编排，行文的方式，一定对你写文章、写书大有帮助。</p><p>最后，感受下Flask的简洁优美，领悟Flask是怎样建立生态的。下面列出了《Flask Web Development》中使用到的Flask扩展：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pip list | grep Flask</span><br><span class="line">Flask (0.10.1)</span><br><span class="line">Flask-Bootstrap (3.3.6.0)</span><br><span class="line">Flask-HTTPAuth (3.1.2)</span><br><span class="line">Flask-Login (0.3.2)</span><br><span class="line">Flask-Mail (0.9.1)</span><br><span class="line">Flask-Migrate (1.8.1)</span><br><span class="line">Flask-Moment (0.5.1)</span><br><span class="line">Flask-PageDown (0.2.1)</span><br><span class="line">Flask-Script (2.0.5)</span><br><span class="line">Flask-SQLAlchemy (2.1)</span><br><span class="line">Flask-WTF (0.12)</span><br></pre></td></tr></table></figure><p>再看看各个模块是怎么组织起来的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask.ext.bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">from</span> flask.ext.mail <span class="keyword">import</span> Mail</span><br><span class="line"><span class="keyword">from</span> flask.ext.moment <span class="keyword">import</span> Moment</span><br><span class="line"><span class="keyword">from</span> flask.ext.sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> flask.ext.login <span class="keyword">import</span> LoginManager</span><br><span class="line"><span class="keyword">from</span> flask.ext.pagedown <span class="keyword">import</span> PageDown</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap()</span><br><span class="line">mail = Mail()</span><br><span class="line">moment = Moment()</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line">pagedown = PageDown()</span><br><span class="line"></span><br><span class="line">login_manager = LoginManager()</span><br><span class="line">login_manager.session_protection = <span class="string">'strong'</span></span><br><span class="line">login_manager.login_view = <span class="string">'auth.login'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">(config_name)</span>:</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    bootstrap.init_app(app)</span><br><span class="line">    mail.init_app(app)</span><br><span class="line">    moment.init_app(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line">    login_manager.init_app(app)</span><br><span class="line">    pagedown.init_app(app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> app.debug <span class="keyword">and</span> <span class="keyword">not</span> app.testing <span class="keyword">and</span> <span class="keyword">not</span> app.config[<span class="string">'SSL_DISABLE'</span>]:</span><br><span class="line">        <span class="keyword">from</span> flask.ext.sslify <span class="keyword">import</span> SSLify</span><br><span class="line">        sslify = SSLify(app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> .main <span class="keyword">import</span> main <span class="keyword">as</span> main_blueprint</span><br><span class="line">    app.register_blueprint(main_blueprint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> .auth <span class="keyword">import</span> auth <span class="keyword">as</span> auth_blueprint</span><br><span class="line">    app.register_blueprint(auth_blueprint, url_prefix=<span class="string">'/auth'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> .api_1_0 <span class="keyword">import</span> api <span class="keyword">as</span> api_1_0_blueprint</span><br><span class="line">    app.register_blueprint(api_1_0_blueprint, url_prefix=<span class="string">'/api/v1.0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书是偶然在一篇博客&lt;a href=&quot;http://python.jobbole.com/85620/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《如果有人让你推荐Python技术书，请让他看这个列表》&lt;/a&gt;中看到的，《Flask Web Development》被列在进阶级，豆瓣评分8.6，算是比较高，比较受公众认可的了。正好最近工作中要用到Web开发相关知识，花了两天时间看了下这本书，果然没让人失望。&lt;/p&gt;
&lt;p&gt;这是一本写作技巧和Web技术并重的书，从第一页开始就让你爱不释手，想一口气读完，酣畅淋漓。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://consen.github.io/categories/Python/"/>
    
    
      <category term="Book" scheme="https://consen.github.io/tags/Book/"/>
    
      <category term="Flask" scheme="https://consen.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Why HHKB</title>
    <link href="https://consen.github.io/2016/06/13/why-hhkb/"/>
    <id>https://consen.github.io/2016/06/13/why-hhkb/</id>
    <published>2016-06-13T22:59:38.000Z</published>
    <updated>2017-11-15T15:05:03.245Z</updated>
    
    <content type="html"><![CDATA[<p>作为一枚程序猿，每天接触最多的工具即是键盘，写代码、写文档、发邮件，总之，在电脑之前坐下便键不离手。</p><p>上大学时用的笔记本电脑，对键盘没有特别在意；工作前两年用的是公司发的键盘，同事花成百上千买了好键盘我也不以为意，心想用普通键盘也能写出好代码，何必做出那种浪费。直到渐渐发觉手关节有些许疼痛，才下定决心买一款舒适好用的键盘。</p><a id="more"></a><p>说起好一点的键盘，你一定听说过机械键盘，什么黑轴青轴红轴茶轴，但是作为程序猿必备键盘，当属HHKB。HHKB处于键盘金字塔顶端，要用就用最好的。（之前手机买的是Android国产品牌，以为够用了，至少坚挺2-3年，没想到用了一年就坏了，果断入手iPhone。）<strong>一款优秀高端的产品带给你的不仅仅是实用的功能，还有很多附加价值。</strong></p><p>HHKB全称Happy Hacking Keyboard，产自日本，由和田英一和PFU研究所共同开发，于1996年12月开始销售。</p><p>因为经常听到机械键盘噼里啪啦的敲击声，甚是扰人，我喜欢安静，也不想打扰别人，所以入手的是HHKB Type-S （Silent）静音版，花费1920RMB。静音版(Type-S)和普通版(Normal)在声音上的区别，可以观看下这个视频，<a href="https://www.youtube.com/watch?v=TBDXtLh_7Y0" target="_blank" rel="external">Compare Sound of HHKB Pro2 Normal and Type-S Part 3</a>，Normal击键声音清脆响亮，Type-S击键声音柔和低沉。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/why-hhkb/hhkb-type-s.jpg" alt="HHBK-Type-S"></p><p>开箱验货，首先映入眼帘的是HHKB小巧精致的布局，取消了数字键、功能键、方向键等一般PC键盘都有但非必要的按键，只有60枚按键，大大减少空间占用，方便携带。当然，这些不常用的键仍然可以通过组合键来输入， 比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Fn + [   -&gt; ↑</span><br><span class="line">2. Fn + /   -&gt; ↓</span><br><span class="line">3. Fn + ;   -&gt; ←</span><br><span class="line">4. Fn + &apos;   -&gt; →</span><br><span class="line">5. Fn + Tab -&gt; Caps</span><br><span class="line">6. Fn + `   -&gt; Del</span><br><span class="line">7. Fn + \   -&gt; Ins</span><br></pre></td></tr></table></figure><p>跟普通键盘布局最大的不同就是Control键了，直接放在A键左边，刚开始使用会特别不适应，用一会就能渐渐体会其妙处及用意，经常在Linux下做开发，Control键放在这个位置再合适不过了，Bash、Vim、Emacs、Tmux，这些用Control键来组合快捷键的工具，用起来更加舒适。</p><p>HHKB键盘上一些按键做了特定角度的倾斜，按起来相当舒适，比如最上面一排键，按下弹起的触感真是太妙了。</p><p>HHKB还提供了6个DIP开关，通过这些开关的组合，可以交换键盘上一些键的位置，或者是改变某些键的功能，让HHKB在Windows/Linux/Mac OS下工作。我的办公机是Windows，远程连接到Linux服务器进行开发，所以开启了开关SW2和SW3，这样按Meta键◇会弹出Windows开始菜单，按Delete键是Backspace，做文本删除操作更符合之前的习惯。</p><p>总之，HHKB是特别适合Linux程序员入手的一款键盘，能让你更好地忘记鼠标，纯键盘操作。用着这样的神器心情也会好很多，工作效率事半功倍。</p><p>纵孙悟空有七十二般变化，也需要金箍棒这样的利器，遇佛杀佛，遇魔降魔。</p><p><img src="http://7xtc3e.com1.z0.glb.clouddn.com/why-hhkb/wukong.jpg" alt="sunwukong"></p><p>参考链接：</p><ol><li><a href="https://zh.wikipedia.org/wiki/Happy_Hacking_Keyboard" target="_blank" rel="external">维基百科 Happy Hacking Keyboard</a></li><li><a href="http://blog.daocloud.io/hhkb/" target="_blank" rel="external">HHKB：神器那点事儿</a></li><li><a href="https://elitekeyboards.com/products.php?sub=pfu_keyboards,hhkbpro2&amp;pid=pdkb400ws#" target="_blank" rel="external">Happy Hacking Professional 2 Type “S” (White/Gray)</a></li><li><a href="https://deskthority.net/wiki/Topre_switch" target="_blank" rel="external">Topre switch</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一枚程序猿，每天接触最多的工具即是键盘，写代码、写文档、发邮件，总之，在电脑之前坐下便键不离手。&lt;/p&gt;
&lt;p&gt;上大学时用的笔记本电脑，对键盘没有特别在意；工作前两年用的是公司发的键盘，同事花成百上千买了好键盘我也不以为意，心想用普通键盘也能写出好代码，何必做出那种浪费。直到渐渐发觉手关节有些许疼痛，才下定决心买一款舒适好用的键盘。&lt;/p&gt;
    
    </summary>
    
      <category term="Developer" scheme="https://consen.github.io/categories/Developer/"/>
    
    
      <category term="HHKB" scheme="https://consen.github.io/tags/HHKB/"/>
    
  </entry>
  
  <entry>
    <title>C++面试我一定会问的一个问题</title>
    <link href="https://consen.github.io/2016/05/21/a-question-i-will-ask-in-cpp-interview/"/>
    <id>https://consen.github.io/2016/05/21/a-question-i-will-ask-in-cpp-interview/</id>
    <published>2016-05-21T20:10:36.000Z</published>
    <updated>2017-11-15T13:13:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>C++是一门难学易用的语言，如果没有深刻理解一些基本概念，编写的代码就会经常出现一些奇怪的问题。</p><p>下面这个问题就是我当初学习C++ OOP概念时遇到的，也是我在工作中遇到的，这个问题没有复杂的技巧，也不是“茴香豆的茴有几种写法”之类的死板教条，只要你基础扎实，一定能回答出来。</p><p>问题很简单，我们都知道，C++中基类指针可以指向派生类对象，那么下面的代码是否正确？</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    Base(<span class="keyword">int</span> a): a(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> a): Base(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   Base* pb;</span><br><span class="line">   pb = &amp;d;</span><br><span class="line">   pb-&gt;Print();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有啥想法了吗？</p><p>如果没有，编译时会输出下面信息，能看出什么端倪了吗？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ test.cpp -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:27: error: ‘class Base’ has no member named ‘Print’</span><br></pre></td></tr></table></figure><p>提示错误：基类‘Base’没有成员的名字是‘Print’，我们预想通过基类指针去调用派生类的函数成员。</p><blockquote><p>“如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。”</p><p>–《C++ Primer》第四版中文版480页</p></blockquote><p>没错，如果要想通过基类指针调用派生类的函数成员，得将函数定义成虚函数，像下面这样：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    Base(<span class="keyword">int</span> a): a(a) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> a): Base(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   Base* pb;</span><br><span class="line">   pb = &amp;d;</span><br><span class="line">   pb-&gt;Print();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ test.cpp -o test</span><br><span class="line">$ ./test </span><br><span class="line">a: 100</span><br></pre></td></tr></table></figure><p>这里涉及到C++ OOP的多态概念，希望你通过此问题对C++多态有更深入的理解，如果有兴趣，还可以再研究下C++多态是怎么实现的，什么是虚函数表，相信你会有大彻大悟的感觉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++是一门难学易用的语言，如果没有深刻理解一些基本概念，编写的代码就会经常出现一些奇怪的问题。&lt;/p&gt;
&lt;p&gt;下面这个问题就是我当初学习C++ OOP概念时遇到的，也是我在工作中遇到的，这个问题没有复杂的技巧，也不是“茴香豆的茴有几种写法”之类的死板教条，只要你基础扎实，一定能回答出来。&lt;/p&gt;
&lt;p&gt;问题很简单，我们都知道，C++中基类指针可以指向派生类对象，那么下面的代码是否正确？&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://consen.github.io/categories/C/"/>
    
    
      <category term="OOP" scheme="https://consen.github.io/tags/OOP/"/>
    
  </entry>
  
</feed>
